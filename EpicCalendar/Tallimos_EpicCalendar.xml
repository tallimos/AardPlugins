<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, November 23, 2020, 12:40 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Tallimos_EpicCalendar" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Tallimos_EpicCalendar"
   author="Tallimos"
   id="1d1e01d90f0e2983c358b32e"
   language="Lua"
   purpose="Allows the user to store upcoming epic run dates and allows for an automated way of telling people"
   save_state="y"
   date_written="2020-11-23 12:39:41"
   requires="4.36"
   version="2.31"
   >
   
</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
	<trigger
		enabled="n"
		group="NoteUpdate"
		match="^No such note.$"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		script="NoNoteFound"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdate"
		match="^$"
		sequence="300"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdate"
		match="^Current forum changed to Epics\. You can read and write in this forum\."
		sequence="100"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdate"
		match="^To\s+\:\s(\w+)"
		sequence="100"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdateLine1"
		match="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdateLine2"
		script="NoteUpdateEnableEnd"
		match="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdateNoteContent"
		match="^$"
		sequence="200"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdateEnd"
		match="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		script="NoteUpdateEnd"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdate"
		script="NoteUpdateSubject"
		match="^From\s+\:\s(\w+)\:\s(.*)"
		sequence="110"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdate"
		script="NoteUpdateNoteNum"
		match="^Forum\s+\:\s(\w+)\s\-\s\#(\d+)"
		sequence="100"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="NoteUpdate"
		script="NoteUpdateNoteDate"
		match="^Date\s+\:\s(\w+)\s(\w+)\s+(\d+)\s+(\d+)\:(\d+)\:(\d+)\s(\d+)"
		sequence="100"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetCurrentBoardTrig2"
		match="You can only read posts in this forum."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetBoardEndTrig"
		script="GetBoardEnd"
		match="^Current forum changed to (\w+)\. You can read and write in this forum\."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetBoardEndTrig"
		script="GetBoardEnd"
		match="^Current forum changed to (\w+)\. You can only read in this forum\."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetCurrentBoardTrig"
		script="CurrentBoard"
		match="^Your current forum is (\w+)\."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetCurrentBoardTrig"
		match="You have no unread notes in any subscribed forum."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetCurrentBoardTrig2"
		match="You can read and write posts in this forum."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetCurrentBoardTrig2"
		match="Use 'forums all' to see subscribed forums."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetCurrentBoardTrig2"
		match="Use 'subscribe' to see all forums and which you are subscribed to."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetCurrentBoardTrig"
		match="+-------+------------+-----------+---------------------------------+"
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetCurrentBoardTrig"
		match="\|\sForum\s\|\sName\s+\|\sNew Posts\s\|\sDescription\s+\|"
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="GetCurrentBoardTrig"
		match="\|\s+(\d+)\s\|\s+(\w+)\s\|\s+(\d+)\s\|\s(.*?)\s+\|"
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="BotCommandCapture"
		match="^(\w+)\stells\syou\s\'\!(help|noteremove|listleader|listday|epiclist|listepic|listepics|nextepic|nextday|nextleader|update)\s?(.*?)?\'$"
		name="TellChannel"
		script="TellChannel"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="BotCommandCapture"
		match="^You tell the CLAN\:\s\'\!(help|noteremove|listleader|listday|epiclist|listepic|listepics|nextepic|nextday|nextleader|update)\s?(.*?)?\'$"
		name="ClanChannelYou"
		script="ClanChannelYou"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="BotCommandCapture"
		match="^\(Group\)\s(\w+)\:\s\'\!(help|noteremove|listleader|listday|epiclist|listepic|listepics|nextepic|nextday|nextleader|update)\s?(.*?)?\'$"
		name="GroupChannel"
		script="GroupChannel"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="BotCommandCapture"
		match="^\(Friend\)\s(\w+)\:\s\'\!(help|noteremove|listleader|listday|epiclist|listepic|listepics|nextepic|nextday|nextleader|update)\s?(.*?)?\'$"
		name="FriendChannel"
		script="FriendChannel"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="BotCommandCapture"
		match="^You tell your friends\:\s\'!(help|noteremove|listleader|listday|epiclist|listepic|listepics|nextepic|nextday|nextleader|update)\s?(.*?)?\'$"
		name="FriendChannelYou"
		script="FriendChannelYou"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>	
	<trigger
		enabled="n"
		group="BotCommandCapture"
		match="^(\w+)\s\((?:.*?)\)\stells the CLAN\:\s\'\!(help|noteremove|listleader|listday|epiclist|listepic|listepics|nextepic|nextday|nextleader|update)\s?(.*?)?\'$"
		name="ClanChannel"
		script="ClanChannel"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="BotCommandCapture"
		match="^\(Spouse\)\s(\w+)\:\s\!(help|noteremove|listleader|listday|epiclist|listepic|listepics|nextepic|nextday|nextleader|update)\s?(.*?)?$"
		name="SpouseChannel"
		script="SpouseChannel"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="BotCommandCapture"
		match="^\(Spouse\)\:\s\!(help|noteremove|listleader|listday|epiclist|listepic|listepics|nextepic|nextday|nextleader|update)\s?(.*?)?$"
		name="SpouseChannelYou"
		script="SpouseChannelYou"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="SystemTime"
		match="^\s+\*\sAardwolf last restarted on\s\:\s+(\d+)\:(\d+)\:(\d+)\s\-\s(.*?)"
		sequence="100"
		regexp="y"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="SystemTime"
		script="GetSystemTimeTrig"
		match="^\s+\*\sThe system time is\s+\:\s+(\d+)\:(\d+)\:(\d+)\s\-\s(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s(\d+)\s(\w+)\,\s(\d+)"
		sequence="100"
		regexp="y"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="EpicCalendar"
		match="^$"
		sequence="300"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="EpicUpdateEnd"
		match="+------+------------+-------------+-------------------------------------+----+"
		script="EpicUpdateEnd"
		name="EpicUpdateEnd"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="EpicCalendar"
		match="+------+------------+-------------+-------------------------------------+----+"
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="EpicCalendar"
		match="Posts in the Epics forum :"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="EpicCalendarStart"
		match="Current forum changed to Epics. You can read and write in this forum."
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		script="EpicUpdateStart"
		>
	</trigger>
	<trigger
		enabled="n"
		group="EpicCalendar"
		match="^\|\sPost\#\|\sDate/Time\s+\|\sAuthor\s+\|\sSubject\s+\|\Size\|$"
		sequence="100"
		regexp="y"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		match="^INFO\:\sNew\spost\s\#(\d+)\sin\sforum\sEpics\sfrom\s(\w+)\sSubj\:\s(.*?)"
		regexp="y"
		script="EpicNote"
		sequence="100"
		ignore_case="y"
		enabled="y"
		>
	</trigger>
	<trigger
		enabled="n"
		group="EpicCalendar"
		match="^\|?\s+(\d+)\|(.*?)\|(?:\*|\s)(\w+)\s+\|\s(.*)(?:\s+)?\|\s+(\d+)\|$"
		regexp="y"
		script="EpicBoard"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
</triggers>

<!--  Timers  -->

<timers>
	<timer
		name="lastcmdtell" 
		second="5" 
		enabled="n"
		script="LastCmdTell"
		>
	</timer>
	<timer
		name="lastcmdspouse" 
		second="5" 
		enabled="n"
		script="LastCmdSpouse"
		>
	</timer>
	<timer
		name="lastcmdgt" 
		second="5" 
		enabled="n"
		script="LastCmdGT"
		>
	</timer>
	<timer
		name="lastcmdft" 
		second="5" 
		enabled="n"
		script="LastCmdFT"
		>
	</timer>
	<timer
		name="lastcmdclan" 
		second="5" 
		enabled="n"
		script="LastCmdClan"
		>
	</timer>
	<timer
		name="autonodelay" 
		second="10" 
		enabled="n"
		script="RTUpdateNo"
		>
	</timer>
	<timer
		name="HourlyNextEpicNotification" 
		hour="1"  
		enabled="n"
		script="HourlyNextEpicNotification"
		>
	</timer>

</timers>

<!--  Aliases  -->

<aliases>
	<alias
		script="CommandMenu"
		match="^(?:ecal|epiccal|epiccalendar) (.*?)$"
		enabled="y"
		ignore_case="y"
		regexp="y"
		sequence="100"
		>
	</alias>
	<alias
		group="RTUpdateCommands"
		script="RTUpdateYes"
		match="^(yes|y)$"
		enabled="n"
		ignore_case="y"
		regexp="y"
		sequence="100"
		>
	</alias>
	<alias
		group="RTUpdateCommands"
		script="RTUpdateNo"
		match="^(no|n)$"
		enabled="n"
		ignore_case="y"
		regexp="y"
		sequence="100"
		>
	</alias>
</aliases>

<script>
<![CDATA[
-- Helpers Quadrapus, Hader, Fiendish, Areia
require "tprint"
require "mw_theme_base"
require "serialize"
require "commas"
require "gmcphelper"
require "copytable"
require "aardmapper"
require "aard_lua_extras"
require "wait"
require "async"

local epiccalcolour = "red"
local remain_colour   = "lime"
local user_colour   = "yellow"
local reason_colour     = "red"
local remain_colour   = "lime"
local time_colour     = "lightslategrey"
local day_colour      = "lightslategrey"
local leader_colour   = "yellow"
local epic_colour     = "red"
local msg_colour      = "lightslategrey"
local err_colour      = "firebrick"
local help_colour     = "lightslategrey"
local qty_colour      = "cyan"
local optional_colour = "lightcoral"
local command_colour  = "white"
local cmd_required    = "royalblue"
local help_command_colour  = "red"

local noteline = "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-="
NextEpicNotification = 0
ran = false
approxtime = 0

--------------------------------------------
--------------- COMMAND MENU ---------------
--------------------------------------------
function CommandMenu(name, line, wc)
	commandline = trim(string.lower(wc[1]))
	wordtable = utils.split (commandline, " ")

	cmd = wordtable[1]
	
	if cmd == "update" then
		ecal_update()
		EpicMisc["Updating"] = "YES"
	elseif cmd == "tdif" then
		if EpicMisc["TypeTime"] == "SERVER" then
			EpicMisc["TypeTime"] = "USER"
			
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Hour will now display in the user's timezone.")
			Note("")
			
			ColourNote("red", "", "PLEASE NOTE", msg_colour, "", ": Any epic notifications sent via channels or notes will still show server time.")
			Note("")
		elseif EpicMisc["TypeTime"] == "USER" then
			EpicMisc["TypeTime"] = "SERVER"
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Hour will now display in the server's timezone.")
			Note("")
		end
	elseif cmd == "changelog" then
		dbot.print("@DFull changelog:")
		dbot.version.changelog.get(0, endTag) -- show changelog from version 0 to the latest
	elseif cmd == "checkversion" then
		dbot.version.update.release(drlDbotUpdateCheck, endTag)
	elseif cmd == "reset" then
		ResetEpicTable()
		resetcheck = "YES"
	elseif cmd == "nupdate" then
		nnum = wordtable[2]
		
		if tonumber(nnum) ~= nil then
			NoteUpdate(nnum)
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Please enter a note number to check")
			Note("")
		end
	elseif cmd == "list" then
		EpicList()
	elseif cmd == "search" then
		epicname = wordtable[2]
		SearchEpic(epicname)
	elseif cmd == "nextepic" or cmd == "next" then
		if wordtable[2] == nil then
			attrib = nil
			channel = nil
			GetNextEpic(attrib, channel)
		else
			attrib = wordtable[2]

			if attrib == "epic" then
				if wordtable[3] == nil then
					channel = nil
					GetNextEpic(attrib, channel)
				else
					channel = wordtable[3]
					if channel == "tell" then channel = channel .. " " .. wordtable[4] end

					GetNextEpic(attrib, channel) 
				end
			elseif attrib == "help" then
				EpicCalendarHelpNext()
			else
				if wordtable[3] == nil then
					channel = nil
					GetNextEpic(attrib, channel)
				else
					wordcount = 0

					for i,v in ipairs(wordtable) do
						wordcount = wordcount + 1
					end
	
					channel = nil
					tellcheck = "no"
					
					for x = 3, wordcount, 1 do
						if tellcheck == "no" then
							if CheckChannel(wordtable[x]) == "no" then
								if CheckChannelUnapproved(wordtable[x]) == "no" then
									attrib = attrib .. " " .. wordtable[x]
								else
									ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Can not post to that channel.")
									
									return
								end
							else
								channel = wordtable[x]
								
								if channel == "tell" then
									x = x + 1
									channel = channel .. " " .. wordtable[x]
									tellcheck = "yes"
								end
							end
						else
							tellcheck = "no"
						end
					end
					
					GetNextEpic(attrib, channel)
				end
			end
		end
	elseif cmd == "nextleader" then
		leader = wordtable[2]
		channel = wordtable[3]
		
		if channel == "tell" then channel = channel .. " " .. wordtable[4] end
		
		GetNextEpicLeader(leader, channel)
	elseif cmd == "nextday" then
		day = wordtable[2]
		channel = wordtable[3]
		
		if channel == "tell" then channel = channel .. " " .. wordtable[4] end
		
		GetNextEpicDay(day, channel)
	elseif cmd == "rt" or cmd == "runtime" then
		attrib = wordtable[2]
		
		if attrib == "edit" then
			rtname = string.lower(wordtable[3])
	
			if rtname == nil then
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Command Usage: ", qty_colour, "", "ecal rt edit <epic name> <runtime in minutes>")
				Note("")
			else
				rttime = wordtable[4]
			
				if tonumber(rttime) == nil then
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Command Usage: ", qty_colour, "", "ecal rt edit <epic name> <runtime in minutes>")
					Note("")
				else
					AddRemoveEditRunTime(attrib, rtname, rttime)		
				end
			end
		elseif attrib == "list" then
			ListRunTimes()	
		elseif attrib == "gt" then
			gtime = wordtable[3]
			
			if gtime == nil then 
				ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", EpicMisc["ApproxRunTimes"]["Grouping Time"]["Time"], msg_colour, "", " minutes have been allocated for the grouping time for the approximate run time calculation.")
			elseif gtime == "enable" then
				if EpicMisc["ApproxRunTimes"]["Grouping Time"]["Enabled"] == true then
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Grouping time calculation has already been ", qty_colour, "", "enabled")
				else
					EpicMisc["ApproxRunTimes"]["Grouping Time"]["Enabled"] = true
					
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Grouping time will be taken into account when calculating approximate start times. Current grouping time set to ", qty_colour, "", EpicMisc["ApproxRunTimes"]["Grouping Time"]["Time"], msg_colour, "", " minutes.")
					
					RunTimeUpdate()
				end
			elseif gtime == "disable" then			
				if EpicMisc["ApproxRunTimes"]["Grouping Time"]["Enabled"] == false then 
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Grouping time calculation has already been ", qty_colour, "", "disabled")
				else
					EpicMisc["ApproxRunTimes"]["Grouping Time"]["Enabled"] = false				
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Grouping time will not be taken into account when calculating approximate start times.")
					
					RunTimeUpdate()
				end
			elseif tonumber(gtime) ~= nil then
				gtime = tonumber(gtime)
				gtime = math.floor(gtime)
				
				if gtime < 1 then
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Grouping time cannot be set to below ", qty_colour, "", "1", msg_colour, "", " minute.")
					
					return
				end
				
				EpicMisc["ApproxRunTimes"]["Grouping Time"]["Time"] = gtime
				
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Grouping time allocation has been changed to ", qty_colour, "", EpicMisc["ApproxRunTimes"]["Grouping Time"]["Time"], msg_colour, "", " minutes.")
				
				if EpicMisc["ApproxRunTimes"]["Grouping Time"]["Enabled"] == true then
					RunTimeUpdate()
				end
			else
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help rt", msg_colour, "", " for more information.")
			end
		elseif attrib == "help" then
			EpicCalendarHelpRT()
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
			Note("")
		end
	elseif cmd == "bot" then
		attrib = wordtable[2]

		if attrib == "enable" then
			if 	EpicMisc["NotificationBot"]["Enabled"] == true then
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Notifcation Bot has already been ", "green", "", "enabled")
			else
				EnableBot()
			end
		elseif attrib == "disable" then
			if 	EpicMisc["NotificationBot"]["Enabled"] == false then
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Notifcation Bot has already been ", "red", "", "disabled")
			else
				DisableBot()
			end
		elseif attrib == "help" then
			EpicCalendarHelpBot()
		elseif attrib == "status" then
			EpicBotStatus()			
		elseif attrib == "add" then
			user = wordtable[3]
			
			if user == "room" then
				NoteRoom(attrib)
			elseif user ~= nil then
				UserPermission(attrib, user)
			else
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Command usage ", qty_colour, "", "ecal bot add <user name>", msg_colour, "", ".")
				Note("")
			end
		elseif attrib == "remove" then
			user = wordtable[3]

			if user == "room" then
				NoteRoom(attrib)
			elseif user ~= nil then
				UserPermission(attrib, user)
			else
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Command usage ", qty_colour, "", "ecal bot remove <user name>", msg_colour, "", ".")
				Note("")
			end
		elseif attrib == "permissions" then
			TogglePermissions()
		elseif attrib == "plist" then
			ListPermissions()
		elseif attrib == "list" then
			if wordtable[3] == "room" then
				ListRooms()
			else
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help bot", msg_colour, "", " for more information.")
				Note("")
			end
		elseif attrib == "auto" then
			sub = wordtable[3]
			
			if sub == "list" then
				ListChannels(attrib)
			elseif sub == "enable" then
				if wordtable[4] ~= nil then
					channel = wordtable[4]
					
					if EpicMisc["NotificationBot"]["Auto"][channel] == nil then
						ColourNote(qty_colour, "", channel, msg_colour, "", " has not been added to the automatic next epic notification list")
						Note("")
					else
						ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Automatic next epic notifications for ", qty_colour, "", channel, msg_colour, "", " have been ", "green", "", "Enabled.")
						Note("")
						EpicMisc["NotificationBot"]["Auto"][channel] = true
					end
				else
					if EpicMisc["NotificationBot"]["AutoEnabled"] == true then
						ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Automatic next epic notification system has already been ", "green", "", "Enabled.")
					else
						EpicMisc["NotificationBot"]["AutoEnabled"] = true
						
						if EpicMisc["NotificationBot"]["Enabled"] == true then
							EnableAutoBot()
						else
							ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Automatic next epic notification system has been ", "green", "", " Enabled.", msg_colour, "", " The notification bot is currently disabled. Please type ", qty_colour, "", "ecal bot enable", msg_colour, "", " to use this feature.")
						end
					end
				end
			elseif sub == "disable" then
				if wordtable[4] ~= nil then
					channel = wordtable[4]
					
					if EpicMisc["NotificationBot"]["Auto"][channel] == nil then
						ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", channel, msg_colour, "", " has not been added to the auto notification list")
						Note("")
					else
						EpicMisc["NotificationBot"]["Auto"][channel] = false
						
						ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Automatic next epic notifications for ", qty_colour, "", channel, msg_colour, "", " have been ", "red", "", "Disabled.")
						Note("")
					end
				else
					if EpicMisc["NotificationBot"]["AutoEnabled"] == false then
						ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Automatic next epic notification system has already been ", "red", "", "Eisabled")
					else						
						EpicMisc["NotificationBot"]["AutoEnabled"] = false
						DisableAutoBot()
					end
				end
			else
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help bot", msg_colour, "", " for more information.")
				Note("")
			end
		elseif attrib == "commands" then
			sub = wordtable[3]
			
			if sub == "list" then
				ListChannels(attrib)
			elseif sub == "enable" then
				if wordtable[4] ~= nil then
					channel = wordtable[4]

					if EpicMisc["NotificationBot"]["Commands"][channel] == nil then
						ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", channel, msg_colour, "", " has not been added to the command channel notification list")
						Note("")
					else
						ChannelCommandEnable(channel)
					end
				else
					if EpicMisc["NotificationBot"]["CommandsEnabled"] == true then
						ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel Commands System has already been ", "green", "", "Enabled")
					else
						EpicMisc["NotificationBot"]["CommandsEnabled"] = true

						if EpicMisc["NotificationBot"]["Enabled"] == true then
							EnableCommandBot()
						else
							ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel Commands System has been ", "green", "", " Enabled.", msg_colour, "", " The Notification Bot is currently ", "red", "", "Disabled", msg_colour, "", ". Please type ", qty_colour, "", "ecal bot enable", msg_colour, "", " to use this feature.")
						end
					end
				end
			elseif sub == "disable" then
				if wordtable[4] ~= nil then
					channel = wordtable[4]
				
					if EpicMisc["NotificationBot"]["Commands"][channel] == nil then
						ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", channel, msg_colour, "", " has not been added to the command channel notification list")
						Note("")
					else
						ChannelCommandDisable(channel)
					end
				else
					if EpicMisc["NotificationBot"]["CommandsEnabled"] == false then
						ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel Commands System has already been ", "red", "", "Disabled")
					else
						EpicMisc["NotificationBot"]["CommandsEnabled"] = false
						DisableCommandBot()	
					end
				end
			else
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help bot", msg_colour, "", " for more information.")
				Note("")
			end
		elseif attrib == "alert" then
			sub = wordtable[3]
			
			if sub == "enable" then
				if EpicMisc["NotificationBot"]["AlertEnabled"] == true then
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Upcoming Epic Alert System has already been ", "green", "", "Enabled")
				else
					EpicMisc["NotificationBot"]["AlertEnabled"] = true
					
					if EpicMisc["NotificationBot"]["Enabled"] == true then
						EnableAlertBot()
					else
						ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Upcoming Epic Alert System has been ", "green", "", " Enabled.", msg_colour, "", " The Notification Bot is currently ", "red", "", "Disabled", msg_colour, "", ". Please type ", qty_colour, "", "ecal bot enable", msg_colour, "", " to use this feature.")
					end
				end
			elseif sub == "disable" then
				if EpicMisc["NotificationBot"]["AlertEnabled"] == false then
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Alert System has already been ", qty_colour, "", "disabled")
				else
					EpicMisc["NotificationBot"]["AlertEnabled"] = false
					DisableAlertBot()
				end
			else
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help bot", msg_colour, "", " for more information.")
				Note("")
			end
		elseif attrib == "blacklist" or attrib == "bl" then
			if wordtable[3] == nil then
				ListBlacklist()
			else
				sub = wordtable[3]
				
				if sub == "enable" then
					EpicMisc["BlacklistEnabled"] = true
					
					if EpicMisc["NotificationBot"]["Enabled"] == true then
						EnableBlacklist()
					else
						ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel Command User Blacklist has been ", "green", "", " Enabled.", msg_colour, "", " The Notification Bot is currently ", "red", "", "Disabled", msg_colour, "", ". Please type ", qty_colour, "", "ecal bot enable", msg_colour, "", " to use this feature.")
					end
				elseif sub == "disable" then
					if EpicMisc["BlacklistEnabled"] == false then
						ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel Command User Blacklist has already been ", "red", "", "Disabled")
					else
						DisableBlacklist()
					end					
				elseif sub == "add" then
					reason = nil
					
					user = wordtable[4]
					wordcount = 0

					for i,v in ipairs(wordtable) do
						wordcount = wordcount + 1
					end
					
					for x = 5, wordcount, 1 do
						if reason == nil then
							reason = wordtable[x]
						else
							reason = reason .. " " .. wordtable[x]
						end
					end
					
					if reason == nil then reason = "N/A" end
					
					AddBlacklist(user, reason)
				elseif sub == "remove" then
					user = wordtable[4]
					RemoveBlacklist(user)
				else
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", help_command_colour, "", "ecal help bot", msg_colour, "", " for more information.")
				end
			end
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help bot", msg_colour, "", " for more information.")
			Note("")
		end
	elseif cmd == "vi" then		
		if EpicMisc["VI"] == "YES" then
			EpicMisc["VI"] = "NO"
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "VI friendy option disabled.")
			Note("")
		elseif EpicMisc["VI"] == "NO" then
			EpicMisc["VI"] = "YES"
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "VI friendy option enabled.")
			Note("")
		end
	elseif cmd == "help" then
		if wordtable[2] == nil then
			EpicCalendarHelp()
		else
			attrib = wordtable[2]
			
			if attrib == "bot" then
				EpicCalendarHelpBot()
			elseif attrib == "next" then
				EpicCalendarHelpNext()
			elseif attrib == "rt" or attrib == "runtime" then
				EpicCalendarHelpRT()
			elseif attrib == "credits" then
				EpicCalendarHelpCredits()
			else
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
				Note("")
			end
		end
	else		
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")
	end
	
	SaveState()
end -- CommandMenu

---------------------------------------------
-------------- CHECK FUNCTIONS --------------
---------------------------------------------
function CheckChannel(word)	
	ccheck = "no"

	for i, v in ipairs(ApprovedChannels) do
		SearchItem = v
		len = string.len(SearchItem)

		if string.find(string.sub(SearchItem,1,len),word) ~= nil then
			ccheck = "yes"
		end
	end
	
	return ccheck
end -- CheckChannel

function CheckChannelUnapproved(word)	
	cucheck = "no"

	for i, v in ipairs(UnApprovedChannels) do
		SearchItem = v
		len = string.len(SearchItem)

		if string.find(string.sub(SearchItem,1,len),word) ~= nil then
			cucheck = "yes"
		end
	end
	
	return cucheck
end -- CheckChannelUnapproved

function CheckRoom()
	GetRoom()
	
	roomcheck = "no"
	
	for i, v in pairs(EpicMisc["NoteRooms"]) do
		if i == gmcproomid then
			roomcheck = "yes"
		end	
	end

	return roomcheck
end -- CheckRoom

function CheckPermission(CheckName)
    local name = string.lower(CheckName)
	pcheck = "no"
	
	GetCharName()
	
	if name == charname then
		pcheck = "yes"
		return pcheck
	end
	
	for i, v in pairs(EpicPermissionTable) do
		if i == name then
			pcheck = "yes"
		end	
	end
	
	return pcheck
end -- CheckPermission

function CheckEpic(echeck, subjectline)
    local words = string.split(subjectline," ")
    
    for i,v in pairs(words) do
        if echeck == v then return v end
    end
    return nil
end -- CheckEpic

function CheckLowest(index)
	if CheckOver(index) == "NO" then
		ReturnType = "table"
		ttable = EpicTimeDifference(index, ReturnType)

		if ttable ~= nil then 
			seconds = TimeToSeconds(ttable)
		end

		if seconds ~= nil then
			if seconds < lowestseconds then 
				lowestseconds = seconds
				lowestindex = index
			end
		end
	end
end -- CheckLowest

function CheckMob(CheckName)
    local name = string.lower(CheckName)
	mcheck = "no"
	
    for i, v in ipairs(EpicMobs) do
		if v == name then
			mcheck = "yes"
		end	
	end
	return mcheck
end -- CheckMob

function CheckEpicName(CheckEpicName)
	repic = nil
	
	if CheckEpicName == "if2" then
		repic = "icefall2"
	elseif CheckEpicName == "if1" then
		repic = "icefall1"
	elseif CheckEpicName == "if" then
		repic = "icefall1"
	elseif CheckEpicName == "transcend" or CheckEpicName == "ts" then -- trans add
		repic = "transcendence"
	else
		repic = CheckEpicName
	end	
	
	return repic
end -- CheckEpicName

---------------------------------------------
-------- GET CURRENT BOARD FUNCTIONS --------
---------------------------------------------
function GetCurrentBoard()
	world.EnableGroup ("GetCurrentBoardTrig", 1)
	world.EnableGroup ("GetCurrentBoardTrig2", 1)
	SendNoEcho ("board")
end -- GetCurrentBoard

function CurrentBoard(name, line, wc)
	cboard = wc[1]
	world.EnableGroup ("GetCurrentBoardTrig", 0)
end -- CurrentBoard

function EndGetCurrentBoard()
	world.EnableGroup ("GetCurrentBoardTrig", 0)
end -- EndGetCurrentBoard

function GetBoardEnd()
	world.EnableGroup ("GetBoardEndTrig", 0)
	world.EnableGroup ("GetCurrentBoardTrig2", 0)
end -- GetBoardEnd

---------------------------------------------
--------- MAIN EPIC TABLE FUNCTIONS ---------
---------------------------------------------
function UpdateEpicTable()	
	if SystemTimeTable["year"] == 0 then
		listtype = "none"
		GetSystemTime()
	end	
	
	GetCurrentBoard()
	
	world.EnableGroup ("EpicCalendar", 1)
	SendNoEcho ("board epics")
	SendNoEcho ("note list")
end -- UpdateEpicTable

function ResetEpicTable()	
	if SystemTimeTable["year"] == 0 then
		listtype = "none"
		GetSystemTime()
	end	

	nucheck = "NO"
	
	EpicTable = {}
	TableIndex = 0
	
	GetCurrentBoard()
	
	world.EnableGroup ("EpicCalendarStart", 1)
	SendNoEcho ("board epics")
end-- ResetEpicTable

function EpicUpdateStart()
	world.EnableGroup ("EpicCalendar", 1)
	SendNoEcho ("note list")
end

function EpicUpdateEnd()
	world.EnableGroup ("EpicCalendarStart", 0)
	world.EnableGroup ("EpicCalendar", 0)
	world.EnableGroup ("EpicUpdateEnd", 0)

	for i,v in ipairs(EpicTable) do
		if CheckOver(i) == "YES" then
			table.remove (EpicTable, i)
		end
	end
	
	if resetcheck == "YES" then
		resetcheck = "NO"
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Epic list has been updated.")
		Note("")
	end
	
	if resetchannel ~= nil then
		SendNoEcho (resetchannel .. " @R[EpicCAL] @DList has been updated.@w")
		resetchannel = nil
	end
	
	world.EnableGroup ("GetBoardEndTrig", 1)
	
	SendNoEcho ("board " .. cboard)
	
		if TableFilled == "NO" then
		TableFilled = "YES"

		if EpicMisc["NotificationBot"]["AlertEnabled"] == true then
			AlertCheck()
		end
	end
	
	SaveState()	
end -- EpicUpdateEnd

function EpicNote(name, line, wc)
	cname = string.lower(wc[2])
	
	if (CheckMob(cname) == "no") then		
		ResetEpicTable()
	end
end -- EpicNote

function EpicBoard(name, line, wc)
	notenum = tonumber(wc[1])
	notedate = wc[2]
	cname = string.lower(wc[3])
	
	if (CheckMob(cname) == "no") then
		subjectline = string.lower(wc[4])
		AddEpic(notenum, notedate, cname, subjectline)
	end
end -- EpicBoard

function AddEpic(notenum, notedate, cname, subjectline)
	epiccheck = "NO"	
	aftercheck = "NO"
	afterepic = ""
	beforecheck = "NO"
	beforeepic = ""
	beforeepicorig = ""
	afterepicorig = ""
	todaycheck = "NO"
	approxcheck = "NO"
	approxtime = 0
	addtime1 = 0
	addtime2 = 0
	time1add = "NO"
	tdaycheck = "NO"

	rsub = subjectline
	rwords = utils.split (rsub, " ")
	
	if rwords[1] == "re:" then return end
	
	invalid_characters = ":~!@#$%^&*()_+=-{}[];'|?.,<>"
	invalid_characters_pattern = "["..string.gsub(invalid_characters, ".", "%%%1").."]"

	subjectline2 = subjectline
	subjectline = string.lower(subjectline)
	subjectline = string.gsub(subjectline, invalid_characters_pattern, "")
	
	subjectline = subjectline:gsub("  ", " ")

	wordtable = utils.split (subjectline, " ")
	checkdate = nil

	timecheck = "NO"
	
	for time in subjectline:gmatch("(%d+[%s+]*[ap]m)") do
		time = time:gsub(" ", "")
		
		timecheck = "YES"	
	end
	
	epname = ""

	for wordindex,b in ipairs(wordtable) do
		epiccheck = "NO"
		
		for i,v in ipairs(wordtable) do
			if wordtable[i] == "after" then
				j = i + 1
				k = i - 1
			
				aftercheck = "YES"
				
				afterepic = CheckEpicName(wordtable[j])
				
				afterepicorig = wordtable[j]
				
				ename2 = CheckEpicName(wordtable[k])
				
				approxcheck = "YES"
				
				epname = afterepic
				
				if time1add == "NO" then
					addtime1 = EpicMisc["ApproxRunTimes"][afterepic]
					addtime2 = EpicMisc["ApproxRunTimes"][ename2]

					if addtime2 == nil then 
						k = k - 1

						ename2 = CheckEpicName(wordtable[k])

						addtime2 = EpicMisc["ApproxRunTimes"][ename2]

						if addtime2 == nil then
							addtime2 = 0
						end
					end
				end
			elseif wordtable[i] == "before" then
				j = i + 1
				
				beforecheck = "YES"
				
				beforeepic = CheckEpicName(wordtable[j])
				beforeepicorig = wordtable[j]
			elseif wordtable[i] == "today" then
				todaycheck = "YES"
			end
		end
		
		if aftercheck == "NO" and beforecheck == "NO" then
			if timecheck == "NO" then
				return
			end
		end

		echeckname = ""
		
		for i,v in ipairs(EpicNames) do
			
			if (CheckEpic(EpicNames[i], wordtable[wordindex])) ~= nil and wordtable[wordindex] ~= afterepicorig and wordtable[wordindex] ~= beforeepicorig then 
				epiccheck = "YES"
				
				TableIndex = TableIndex + 1	
				
				if EpicTable[TableIndex] == nil then			
					EpicTable[TableIndex] = {}
					EpicTable[TableIndex]["Index"] = TableIndex
				end

				if EpicTable[TableIndex]["Epic Name"] == nil then
					EpicTable[TableIndex]["Epic Name"] = CheckEpicName(EpicNames[i])
				end
				
 				if i == 9 then 
					if wordtable[wordindex] == "icefall1" or wordtable[wordindex] == "icefall2" then
						TableIndex = TableIndex - 1
						EpicTable[TableIndex]["Epic Name"] = wordtable[wordindex]
					end
				end
				
				echeckname = EpicTable[TableIndex]["Epic Name"]
				
				if approxcheck == "NO" then
					EpicTable[TableIndex]["Approx"] = "NO"

					approxcheck = "YES"
					
					if addtime1 ~= nil then
						approxtime = approxtime + addtime1
						addtime1 = nil
						time1add = "YES"
					end
				else
					EpicTable[TableIndex]["Approx"] = "YES"

					if addtime1 ~= nil then
						approxtime = approxtime + addtime1
						addtime1 = nil
						time1add = "YES"
					end					
				end
			end
		end

		for j,k in ipairs(EpicTable) do
			if EpicTable[j]["Note Number"] == notenum then
				if EpicTable[j]["Epic Name"] == epname then
					epiccheck = "NO"
					table.remove (EpicTable, TableIndex)
					TableIndex = TableIndex - 1
				end
			end
		end				
		
		if epiccheck == "YES" then
			oktoadd = "YES"
			
			for i,v in ipairs(EpicTable) do
				if (tonumber(EpicTable[i]["Note Number"])) == notenum then
					if EpicTable[i]["Epic Name"] == echeckname then
						oktoadd = "NO"
						table.remove (EpicTable, TableIndex)
						TableIndex = TableIndex - 1
					end
				end
			end

			if oktoadd ~= "NO" then
				EpicTable[TableIndex]["Epic Leader"] = cname
				EpicTable[TableIndex]["Note Number"] = notenum
				EpicTable[TableIndex]["Note Date"] = notedate
			
				if todaycheck == "YES" then
					tindex = SystemTimeTable["wday"]
					EpicTable[TableIndex]["Day of Week"] = DaysofWeekShort[tindex]
				else
					DayCheck = "NO"

					for i,v in ipairs(DaysofWeekShort) do
						for q,r in ipairs(wordtable) do
						
							search = wordtable[q]
							SearchItem = DaysofWeekShort[i]
							
							len = string.len(SearchItem)

							for j,k in pairs(string.split(search," ")) do
								if string.find(string.sub(k,1,len),SearchItem) == nil then
								else
									DayCheck = "YES"
									EpicTable[TableIndex]["Day of Week"] = DaysofWeekShort[i]
								end
							end
						end
					end

					if DayCheck == "NO" then
						table.remove (EpicTable, TableIndex)
						TableIndex = TableIndex - 1

						return
					end
				end
				
				for date in subjectline2:gmatch("%a%a%a%d%d") do
					SeperateDate(date)
					checkdate = date
				end

				if checkdate == nil then 
					if DayCheck == "YES" then
						NoDateFound()
					end
				end

				timecheck = "NO"
				
				for time in subjectline:gmatch("(%d+[%s+]*[ap]m)") do
					time = time:gsub(" ", "")
					
					timecheck = "YES"
					
					for tday in time:gmatch("[ap]m") do
						EpicTable[TableIndex]["AMPM"] = tday
					end
					
					SeperateTime(time)
					PopulateTimeTable(TableIndex)
				end			

				if aftercheck == "YES" then
					acfail = "YES"
					
					for i,v in ipairs(EpicTable) do
						if EpicTable[TableIndex]["Day of Week"] == EpicTable[i]["Day of Week"] then
							if EpicTable[i]["Epic Name"] == afterepic then
								if timecheck ~= "YES" then
									
									EpicTable[TableIndex]["Time Table"] = {}
		
									for i,v in pairs(EpicTable[i]["Time Table"]) do
										EpicTable[TableIndex]["Time Table"][i] = v
									end

									EpicTable[TableIndex]["Hour"] = EpicTable[i]["Hour"]
									EpicTable[TableIndex]["Minute"] = EpicTable[i]["Minute"]
									EpicTable[TableIndex]["AMPM"] = EpicTable[i]["AMPM"]
									
									acfail = "NO"

									if EpicTable[TableIndex]["Approx"] == "YES" then
										FixApproxTime(TableIndex, aftercheck)
									end
									
								end
								
								-- EpicTable[TableIndex]["Time Table"] = EpicTable[i]["Time Table"]
							end
						end
					end
					
					if acfail == "YES" then
						table.remove (EpicTable, TableIndex)
						TableIndex = TableIndex - 1
					end
				elseif beforecheck == "YES" then
					for i,v in ipairs(EpicTable) do
						if EpicTable[TableIndex]["Day of Week"] == EpicTable[i]["Day of Week"] then

							if EpicTable[i]["Epic Name"] == beforeepic then
								if timecheck ~= "YES" then
									EpicTable[TableIndex]["Hour"] = EpicTable[i]["Hour"]
									EpicTable[TableIndex]["Time Table"] = EpicTable[i]["Time Table"]
									EpicTable[TableIndex]["Minute"] = EpicTable[i]["Minute"]
									EpicTable[TableIndex]["AMPM"] = EpicTable[i]["AMPM"]
								end
							end
						end
					end
				end
			end
		end
		
		if (GetTriggerOption ("EpicUpdateEnd", "enabled")) == 0 then
			if nucheck == "NO" then
				world.EnableGroup ("EpicUpdateEnd", 1)
			end
		end
	end
end -- AddEpic

function FixApproxTime(atindex, aftercheck)
	hours = 0
	remainmin = 0
	
	if EpicMisc["ApproxRunTimes"]["Grouping Time"]["Enabled"] == true then
		approxtime = approxtime + EpicMisc["ApproxRunTimes"]["Grouping Time"]["Time"]
	end
	
	if approxtime > 59 then 
		hours = math.floor(approxtime / 60)
		remainmin = approxtime - (hours * 60)
	else
		remainmin = approxtime
	end
	
	EpicTable[atindex]["Minute"] = EpicTable[atindex]["Minute"] + remainmin
	EpicTable[atindex]["Time Table"]["min"] = EpicTable[atindex]["Time Table"]["min"] + remainmin
	
	if EpicTable[atindex]["Minute"] > 59 then
		EpicTable[atindex]["Minute"] = EpicTable[atindex]["Minute"] - 60 
		EpicTable[atindex]["Time Table"]["min"] = EpicTable[atindex]["Time Table"]["min"] - 60
		
		hours = hours + 1
	end
	
	orighour = EpicTable[atindex]["Hour"]
	EpicTable[atindex]["Hour"] = EpicTable[atindex]["Hour"] + hours
	EpicTable[atindex]["Time Table"]["hour"] = EpicTable[atindex]["Time Table"]["hour"] + hours
	
	if EpicTable[atindex]["Hour"] > 12 then
		EpicTable[atindex]["Hour"] = EpicTable[atindex]["Hour"] - 12
		EpicTable[atindex]["AMPM"] = "pm"
	elseif EpicTable[atindex]["Hour"] == 12 then
		if EpicTable[atindex]["AMPM"] == "am" then
			EpicTable[atindex]["AMPM"] = "pm"
		end
	end

	if aftercheck ~= nil then 
		apname = EpicTable[atindex]["Epic Name"]
		addtime = EpicMisc["ApproxRunTimes"][apname]
			
		if addtime ~= nil then 
			approxtime = approxtime + addtime
		end
	end
	
	SaveState()
	
	return approxtime
end -- FixApproxTime

function NoDateFound()
	EpicTable[TableIndex]["Time Table"] = {}
    EpicTable[TableIndex]["Time Table"]["month"] = SystemTimeTable["month"]
	EpicTable[TableIndex]["Time Table"]["year"] = SystemTimeTable["year"]
	
	dayindexstart = SystemTimeTable["wday"] -- start with the system's today, i.e. saturday would be 7
	day = EpicTable[TableIndex]["Day of Week"] -- we need the day of week from epic post
	ydaydif = 0
	
	for i = 1, 8, 1 do
		if DaysofWeekShort[dayindexstart] ~= day then
			ydaydif = ydaydif + 1
			dayindexstart = dayindexstart + 1
		else
			break
		end
	
		if dayindexstart > 7 then
			dayindexstart = 1
		end
	end
	
	currentday = SystemTimeTable["day"] + ydaydif
	
	mdindex = EpicTable[TableIndex]["Time Table"]["month"]
	
	maxdays = MonthMaxDays[mdindex]
	
	if currentday > maxdays then
		EpicTable[TableIndex]["Time Table"]["day"] = currentday - maxdays
		EpicTable[TableIndex]["Time Table"]["month"] = EpicTable[TableIndex]["Time Table"]["month"] + 1
		if EpicTable[TableIndex]["Time Table"]["month"] > 12 then
			EpicTable[TableIndex]["Time Table"]["month"] = 1
			EpicTable[TableIndex]["Time Table"]["year"] = EpicTable[TableIndex]["Time Table"]["year"] + 1
		end
	else
		EpicTable[TableIndex]["Time Table"]["day"] = currentday
	end
end -- NoDateFound

function PopulateTimeTable(TableIndex)
		EpicTable[TableIndex]["Time Table"]["sec"] = 0
		EpicTable[TableIndex]["Time Table"]["min"] = tonumber(EpicTable[TableIndex]["Minute"])

		EpicTable[TableIndex]["Time Table"]["hour"] = 0

		if EpicTable[TableIndex]["AMPM"] == "pm" then 
			EpicTable[TableIndex]["Time Table"]["hour"] = EpicTable[TableIndex]["Time Table"]["hour"] + 12
		end
		
		if tonumber(EpicTable[TableIndex]["Hour"]) ~= 12 then
			EpicTable[TableIndex]["Time Table"]["hour"] = EpicTable[TableIndex]["Time Table"]["hour"] + tonumber(EpicTable[TableIndex]["Hour"])
		end
		
		if EpicTable[TableIndex]["AMPM"] == "am" then 
			if tonumber(EpicTable[TableIndex]["Hour"]) == 12 then
				EpicTable[TableIndex]["Time Table"]["hour"] = 23
			end
		end
		
		-- EpicTable[TableIndex]["Time Table"]["year"] = SystemTimeTable["year"]

		for i,v in ipairs(DaysofWeekShort) do
			search = EpicTable[TableIndex]["Day of Week"]
			SearchItem = DaysofWeekShort[i]
			
			len = string.len(SearchItem)

			for j,k in pairs(string.split(search," ")) do
				if string.find(string.sub(k,1,len),SearchItem) == nil then
				else
					EpicTable[TableIndex]["Time Table"]["wday"] = i
				end
			end
		end

		MonthIndex = EpicTable[TableIndex]["Time Table"]["month"]
		yday = MonthsYDay[MonthIndex] + EpicTable[TableIndex]["Time Table"]["day"]
		
		-- if (SystemTimeTable["year"]%4) == 0 then yday = yday + 1 end
		if (EpicTable[TableIndex]["Time Table"]["year"]%4) == 0 then yday = yday + 1 end
		
		EpicTable[TableIndex]["Time Table"]["yday"] = yday
		
		EpicTable[TableIndex]["Time Table"]["isdst"] = false
	
	if EpicTable[TableIndex]["Approx"] == "YES" then
		local tindex = TableIndex - 1
		pttname = EpicTable[tindex]["Epic Name"]
		pttaddtime = EpicMisc["ApproxRunTimes"][pttname]
		
		if pttaddtime ~= nil then
			approxtime = approxtime + pttaddtime
		end
		
		FixApproxTime(TableIndex)
	end
end -- PopulateTimeTable

function EpicList()
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")

		Note("")

		return
	end

	listtype = "list"

	if SystemTimeTable["year"] == 0 then
		GetSystemTime()
	else
		ListEpic()
	end	
end -- EpicList

function CheckType(ltype)
	if ltype == "if1" or ltype == "icefall 1" then
		ltype = "icefall1" 
		return ltype
	elseif ltype == "if2" or ltype == "icefall 2" then
		ltype = "icefall2"
		return ltype
	elseif ltype == "transcend" or ltype == "ts" then -- trans add
		ltype = "transcendence"
		return ltype
	elseif ltype == "if" then
		ltype = "icefall"
		return ltype
	end

	for i,v in pairs(SearchNames) do
		search = string.lower(v)
		SearchItem = string.lower(trim(ltype))

		len = string.len(SearchItem)

		invalid_characters = "~!@#$%^&*()_+=-{}[];'|?.,<>"
		invalid_characters_pattern = "["..string.gsub(invalid_characters, ".", "%%%1").."]"

		SearchItem = string.gsub(SearchItem, invalid_characters_pattern, "")
		
		SearchItem = SearchItem:gsub("  ", " ")

		if string.find(search,SearchItem) == nil then
		else
			ltype = i
		end
	end
	
	return ltype
end -- CheckType

function SearchEpic(epicname)
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end

	if epicname == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Please enter an epic name to search for.")
		Note("")
		return
	end
	
	len = string.len(epicname)
	
	if len < 2 then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Epic name has to be at least two letters to search.")
		Note("")
		return
	else
		local ltype = string.lower(epicname)
		listtype = CheckType(ltype)
		
		if listtype == nil then listtype = ltype end
		
		if SystemTimeTable["year"] == 0 then
			GetSystemTime()
		else
			ListEpic()	
		end	
	end
end -- SearchEpic

function ListEpic()
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end
	
	local hour = ""

	if listtype == "nextleader" then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Please specify a leader to look up")
		Note("")
		return
	end

	if listtype == "list" then		
		title = "Epic Run List"
	else
		listtypeT = string.gsub (listtype, "^.", string.upper)
		title = "Epic Run List - Searching: " .. listtypeT
	end
	
	title2 = "+-----------+-------------+-----------+-----------+---------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
		lendif = lendif * 0.5
	end

	spacing = string.rep(" ", lendif)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
		
		if EpicMisc["TypeTime"] == "SERVER" then
			TimeTitle = "Time-Mud "
		elseif EpicMisc["TypeTime"] == "USER" then
			TimeTitle = "Time-User"
		end
		
		ColourNote(msg_colour, "", "| Epic      | Leader      | Day       | " .. TimeTitle ..  " | Time Until Epic                 |")
		
		ColourNote(msg_colour, "", title2)
	end
	
	errorcheck = "no"
	
	for i,v in ipairs (EpicTable) do
		if EpicTable[i]["Time Table"]["year"] == nil then
			errorcheck = "yes"
		end
	end
	
	if errorcheck ~= "yes" then
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)
	end
 
	if listtype == "list" then
		for i,v in ipairs(EpicTable) do
			if EpicTable[i]["Epic Name"] == "icefall1" then
				ename = "Icefall 1"
			elseif EpicTable[i]["Epic Name"] == "icefall2" then
				ename = "Icefall 2"
			elseif EpicTable[i]["Epic Name"] == "oc" then
				ename = "OC"
			elseif EpicTable[i]["Epic Name"] == "transcendence" then
				ename = "Transcend"
			else 
				if EpicTable[i]["Epic Name"]~= nil then 
					ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
				end
			end
			
			if EpicTable[i]["Epic Leader"] ~= nil then
				eleader = string.gsub (EpicTable[i]["Epic Leader"], "^.", string.upper)
			end

			dindex = EpicTable[i]["Time Table"]["wday"]
			
			if DaysofWeek[dindex] ~= nil then 
				eday = string.gsub (DaysofWeek[dindex], "^.", string.upper)
			end
			
			if EpicTable[i]["Time Table"]["hour"] ~= nil then
				if EpicMisc["VI"] == "YES" then
					ReturnType = "VI"
				else
					ReturnType = "normal"
				end
				
				timedef = EpicTimeDifference(i, ReturnType)

				if EpicMisc["TypeTime"] == "SERVER" then
					hour = EpicHour(i)
				else
					hour, tzdayindex = TimeZoneEpicHour(i)
			
					if tzdayindex ~= dindex then
						if tzdayindex ~= nil then
							if tzdayindex == 0 then tzdayindex = 7 end
							if tzdayindex == 8 then tzdayindex = 1 end
							
							eday = string.gsub (DaysofWeek[tzdayindex], "^.", string.upper)
						end
					end
				end
			end
			
			
			if timedef ~= nil then
				if EpicMisc["VI"] == "YES" then
					timedef = trim(timedef)
				end
			end
			
			DisplayRow(ename, eleader, eday, hour, timedef, i)		
		end
	else
		len = string.len(listtype)

		for i,v in ipairs(EpicTable) do
			epicname = EpicTable[i]["Epic Name"]
			
			if string.find(string.sub(epicname,1,len),listtype) ~= nil then			
				if EpicTable[i]["Epic Name"] == "icefall1" then
					ename = "Icefall 1"
				elseif EpicTable[i]["Epic Name"] == "icefall2" then
					ename = "Icefall 2"
				elseif EpicTable[i]["Epic Name"] == "oc" then
					ename = "OC"
				elseif EpicTable[i]["Epic Name"] == "transcendence" then
					ename = "Transcend"
				else 
					ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
				end

				eleader = string.gsub (EpicTable[i]["Epic Leader"], "^.", string.upper)

				dindex = EpicTable[i]["Time Table"]["wday"]
			
				eday = string.gsub (DaysofWeek[dindex], "^.", string.upper)
				
				if EpicTable[i]["Time Table"]["hour"] ~= nil then
					if EpicMisc["VI"] == "YES" then
						ReturnType = "VI"
					else
						ReturnType = "normal"
					end

					timedef = EpicTimeDifference(i, ReturnType)

					if EpicMisc["TypeTime"] == "SERVER" then
						hour = EpicHour(i)
					else
						hour,tzdayindex = TimeZoneEpicHour(i)
						-- return here
						if tzdayindex ~= dindex then
							-- if tzdayindex ~= nil then
							-- 	if tzdayindex == 0 then tzdayindex = 7 end
							--	if tzdayindex == 8 then tzdayindex = 1 end
								
								eday = string.gsub (DaysofWeek[tzdayindex], "^.", string.upper)
							-- end
						end
					end
				end


				if timedef ~= nil then
					if EpicMisc["VI"] == "YES" then
						timedef = trim(timedef)
					end
				end
				
				DisplayRow(ename, eleader, eday, hour, timedef, i)
			end
		end
	end
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	else
		Note("")
	end
	
	ColourNote(epic_colour, "", "*", msg_colour, "", " - approximate start times only, actual start times may vary")
	Note("")
	
	if EpicMisc["TypeTime"] == "USER" then
		ColourNote(msg_colour, "", "Hour is displayed as the user's time zone. Type ", qty_colour, "", "ecal tdif", msg_colour, "", " to switch hour back to server time.")
		Note("")
	end
end -- ListEpic

function DisplayRow(ename, eleader, eday, hour, timedef, apindex)
	if timedef == nil then
		timedef = "This Epic is over"
		return
	end
	
	if EpicTable[apindex]["Approx"] == "YES" then 
		apxhour = "*"
	else
		apxhour = " "
	end

	if ename == nil then namespace = 9 else namespace = MakeSpace(ename, 9) end

	if eleader == nil then leaderspace = 11 else leaderspace = MakeSpace(eleader, 11) end

	if eday == nil then dayspace = 9 else dayspace = MakeSpace(eday, 9) end
	
	if hour == nil then timespace = 8 else timespace = MakeSpace(hour, 8) end
	
	if timedef == nil then remainspace = 32 else remainspace = MakeSpace(timedef,32) end
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", "| ", epic_colour, "", ename .. namespace, msg_colour, "", " | ", leader_colour, "", eleader .. leaderspace, msg_colour, "", " | ", day_colour, "", eday .. dayspace, msg_colour, "", " | ", time_colour, "", timespace .. hour, epic_colour, "", apxhour, msg_colour, "", " | ", remain_colour, "",remainspace .. timedef, msg_colour, "", "|")
	elseif EpicMisc["VI"] == "YES" then
		ColourNote(msg_colour, "", "Epic: ", epic_colour, "", ename .. namespace, msg_colour, "", " Leader: ", leader_colour, "", eleader .. leaderspace, qty_colour, "", " Start Time: ", day_colour, "", eday, msg_colour, "", " ", time_colour, "", hour, epic_colour, "", apxhour, msg_colour, "", " ", remain_colour, "",timedef)
	end
end -- DisplayRow

function StartPost()
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end
		
	if SystemTimeTable["year"] == 0 then
		listtype = "post"	
		GetSystemTime()
	else
		StartNotePost()
	end
end -- StartPost()

function StartNotePost()
	noteuser = string.gsub (noteuser, "^.", string.upper)

	for i, v in pairs (EpicMisc["PostedNotes"]) do
		if i == noteuser then 
			timenow = os.time()
			timenow2 = EpicMisc["PostedNotes"][noteuser]["Note Sent"]
		
			timediff2 = {}

			timeDiff(timenow,timenow2,timediff2)

			if timediff2 ~= nil then 
				seconds = TimeToSeconds(timediff2)
			end
			
			if seconds < 43199 then
				local remainseconds = 43199 - seconds
				local remainmsg = TimeToNormal(remainseconds)
				
				ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", noteuser, msg_colour, "", " has requested the epic schedule note already within the last 12 hours.")
				
				if EpicMisc["PostedNotes"][noteuser]["Last Request"] == nil then 
					EpicMisc["PostedNotes"][noteuser]["Last Request"] = os.time()
				else				
					local lrtimenow = os.time()
					local lrtimenow2 = EpicMisc["PostedNotes"][noteuser]["Last Request"]
				
					local lrtimediff2 = {}

					timeDiff(lrtimenow,lrtimenow2,lrtimediff2)

					if lrtimediff2 ~= nil then 
						lrseconds = TimeToSeconds(lrtimediff2)
					end
					
					if lrseconds < 3600 then
						return
					end
				end

				EpicMisc["PostedNotes"][noteuser]["Last Request"] = os.time()
			
				SendNoEcho("tell " .. noteuser .. " @R[EpicCAL] @DI am sorry @R" .. noteuser .. " @Dbut you can only request @C1 @Depic schedule note in a @C12 hour @Dtime frame. You may request again in @C" .. remainmsg .. "@D.@w")
				
				SaveState()
				
				return
			end
		end
	end
	
	SendNoEcho ("board personal")
	SendNoEcho ("note write")
	SendNoEcho (noteuser)
	SendNoEcho ("Epic Run Schedule - " .. noteuser)
	PostEpic()
end -- StartNotePost

function PostEpic()
	local hour = ""

	local title = "Epic Run List"
	local title2 = "+---------+-----------+---------+---------+-------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
		lendif = lendif * 0.5
	end

	spacing = string.rep(" ", lendif)
	
	SendNoEcho (spacing .. "@R" .. title .. "@w")
	SendNoEcho ("@w")
	SendNoEcho ("@D" .. title2)
	SendNoEcho ("@D| Epic    | Leader    | Day     | Time    | Time Until Epic               |@w")
	SendNoEcho ("@D" .. title2)
	
	table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)

	for i,v in ipairs(EpicTable) do
		if EpicTable[i]["Epic Name"] == "icefall1" then
			ename = "Icefall 1"
		elseif EpicTable[i]["Epic Name"] == "icefall2" then
			ename = "Icefall 2"
		elseif EpicTable[i]["Epic Name"] == "oc" then
			ename = "OC"
		elseif EpicTable[i]["Epic Name"] == "transcendence" then
			ename = "Transcend"
		else 
			ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
		end

		eleader = string.gsub (EpicTable[i]["Epic Leader"], "^.", string.upper)
		
		dindex = EpicTable[i]["Time Table"]["wday"]

		eday = string.gsub (DaysofWeek[dindex], "^.", string.upper)
		
		if EpicTable[i]["Time Table"]["hour"] ~= nil then
			ReturnType = "VI"
			timedef = EpicTimeDifference(i, ReturnType)

			hour = EpicHour(i)
		end
		
		if timedef ~= nil then
			PostRow(ename, eleader, eday, hour, timedef, i)
		end
	end

	SendNoEcho ("@D" .. title2)
	SendNoEcho ("@w")
	SendNoEcho("@R* @D- approximate start times only, actual start times may vary@w")
	SendNoEcho ("@w")
	
	since = os.time (SystemTimeTable)
	since = os.date ("%a, %d %b %Y - %I:%M:%S %p", since)
	timestamp = "List generated: " .. since .. " (server time)"
	
	SendNoEcho (timestamp)
	SendNoEcho ("end")
	SendNoEcho ("p")
	
	EpicMisc["PostedNotes"][noteuser] = {}
	EpicMisc["PostedNotes"][noteuser]["Note Sent"] = os.time()
	
	SaveState()
end -- PostEpic

function PostRow(ename, eleader, eday, hour, timedef, apindex)
	if EpicTable[apindex]["Approx"] == "YES" then 
		apxhour = "@R*"
	else
		apxhour = " "
	end

	if ename == nil then namespace = 9 else namespace = MakeSpace(ename, 9) end

	if eleader == nil then leaderspace = 11 else leaderspace = MakeSpace(eleader, 11) end

	if eday == nil then dayspace = 9 else dayspace = MakeSpace(eday, 9) end
	
	if hour == nil then timespace = 8 else timespace = MakeSpace(hour, 8) end
	
	if timedef == nil then remainspace = 32 else remainspace = MakeSpace(timedef,32) end
	
	SendNoEcho ("@D|@R" .. ename .. namespace .. "@D|@Y" .. eleader .. leaderspace .. "@D|@w" .. eday .. dayspace .. "@D|@w" .. timespace .. hour .. apxhour .. "@D|@G" .. remainspace .. trim(timedef) .. "@D|@w")
end -- PostRow
 
-----------------------------------------------
------------ NOTE UPDATE FUNCTIONS ------------
-----------------------------------------------
function NoteUpdate(nnum)
	world.EnableGroup ("NoteUpdate", 1)
	world.EnableGroup ("NoteUpdateLine1", 1)
	
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Checking subject line for note #", qty_colour, "", nnum)
	
	nucheck = "YES"
	
	SendNoEcho ("board epics")	
	SendNoEcho ("note read " .. nnum)
end -- NoteUpdate

function NoteUpdateEnd()
	tablecount = table.maxn (EpicTable)

	TableIndex = tablecount
	
	world.EnableGroup ("NoteUpdate", 0)
	world.EnableGroup ("NoteUpdateEnd", 0)
	world.EnableGroup ("NoteUpdateNoteContent", 0)	
	world.EnableGroup ("NoteUpdateLine1", 0)
	world.EnableGroup ("NoteUpdateLine2", 0)

	if (CheckMob(nuleader) == "no") then
		AddEpic(nunotenum, nunotedate, nuleader, nusubjectline)
	end
end -- NoteUpdateEnd

function NoNoteFound()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "No note found. Please check the note number and try again.")

	world.EnableGroup ("NoteUpdate", 0)
	world.EnableGroup ("NoteUpdateEnd", 0)
	world.EnableGroup ("NoteUpdateNoteContent", 0)
	world.EnableGroup ("NoteUpdateLine1", 0)
	world.EnableGroup ("NoteUpdateLine2", 0)
end

function NoteUpdateSubject(name, line, wc)
	world.EnableGroup ("NoteUpdateLine1", 0)
	world.EnableGroup ("NoteUpdateLine2", 1)

	nuleader = string.lower(wc[1])
	nusubjectline = string.lower(wc[2])
end -- NoteUpdateSubject

function NoteUpdateEnableEnd()
	world.EnableGroup ("NoteUpdateLine2", 0)
	world.EnableGroup ("NoteUpdateEnd", 1)
	world.EnableGroup ("NoteUpdateNoteContent", 1)
end -- NoteUpdateEnableEnd

function NoteUpdateNoteNum(name, line, wc)
	nuboard = string.lower(wc[1])
	
	if nuboard == "epics" then
		nunotenum = tonumber(wc[2])
	else
		nunotenum = "error"
	end
end -- NoteUpdateNoteNum

function NoteUpdateNoteDate(name, line, wc)
	month = wc[2]
	day = wc[3]
	hour = wc[4]
	min = wc[5]
	
	if string.len(day) == 1 then day = "0" .. day end
	
	nunotedate = day .. " " .. month .. " " .. hour .. ":" .. min
end -- NoteUpdateNoteDate

----------------------------------------------
--------------- NEXT FUNCTIONS ---------------
----------------------------------------------
function GetNextEpicLeader(leader, channel)
	if leader == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Please specify a leader to look up")
		Note("")
		return
	else
		wnext = string.lower(leader)
	end
	
	LeaderSearch = "YES"

	if channel ~= nil  then 
		if CheckChannel(channel) == "no" then 
			if CheckChannelUnapproved(channel) == "yes" then
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Can not post to that channel.")
				
				return
			end
		end
	end
	
	if channel ~= nil then
		reportchannel = channel
	end
	
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end
	
	if SystemTimeTable["year"] == 0 then
		listtype = "next"
		GetSystemTime()
	else
		NextEpic()
	end
end -- GetNextEpicLeader

function GetNextEpicDay(wday, channel)
	if wday ~= nil then
		wday = string.lower(wday)
	else
		if channel ~= nil then
			SendNoEcho (channel .. " @R[EpicCAL] @CPlease enter a valid day, day can not be blank.@w")
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Please enter a valid day, day can not be blank.")

			Note("")
		end
		
		return
	end

	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end

	if channel ~= nil  then 
		if CheckChannel(channel) == "no" then
			if CheckChannelUnapproved(channel) == "yes" then
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Can not post to that channel.")
				
				return
			end
		end
	end
	
	DaySearch = "YES"
	wnext = nil
	
	if string.len(wday) < 3 then
		if channel ~= nil then
			SendNoEcho (channel .. " @R[EpicCAL] @DYou must input at least 3 characters of the day.@w")
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You must input at least 3 characters of the day.")
			Note("")
		end
		
		return
	elseif string.len(wday) == 3 then
		for i,v in ipairs(DaysofWeekShort) do
		
			len = string.len(DaysofWeekShort[i])
			day = DaysofWeekShort[i]
			search = wday

			if string.find(string.sub(search,1,len),day) ~= nil then
				wnext = day
			end
		end
	else
		for i,v in ipairs(DaysofWeek) do
		
			len = string.len(wday)
			search = DaysofWeek[i]

			if string.find(string.sub(search,1,len),wday) ~= nil then
				wnext = DaysofWeekShort[i]
			end
		end
	end
	
	if wnext ~= nil then
		if channel ~= nil then
			reportchannel = channel
		end
		if SystemTimeTable["year"] == 0 then
			listtype = "next"
			GetSystemTime()
		else
			NextEpic()
		end
	else
		if channel ~= nil then
			SendNoEcho (channel .. " @R[EpicCAL] @C" .. wday .. " @Dis not a valid day.@w")
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", wday, msg_colour, "", " is not a valid day.")
			Note("")
		end
	end
end -- GetNextEpicDay

function GetNextEpic(ename, channel)	
	if ename ==  nil then
		wnext = nil
	else
		wnext = string.lower(ename)
	end
	
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end

	if channel ~= nil  then 
		if CheckChannel(channel) == "no" then
			if CheckChannelUnapproved(channel) == "yes" then
				ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Can not post to that channel.")
				
				return
			end
		end		
	end	

	if channel ~= nil then
		reportchannel = channel
	end
	
	if SystemTimeTable["year"] == 0 then 
		listtype = "next"
		GetSystemTime()
	else
		NextEpic()
	end
end -- GetNextEpic

function GetLowestDay(lowestindex)
	ReturnType = "VI"
	timeremaining = EpicTimeDifference(lowestindex, ReturnType)

	if SystemTimeTable["wday"] == EpicTable[lowestindex]["Time Table"]["wday"] then
		day = "today"
	else
		dayindex = EpicTable[lowestindex]["Time Table"]["wday"]
		day = DaysofWeek[dayindex]
	end

	day = string.gsub (day, "^.", string.upper)
	return day
end -- GetLowestDay

function NextEpic()
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end

	lowestseconds = 604800 -- amount of seconds in a week 
	lowestindex = 0 -- index of epic with lowest amount of seconds

	table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)

	if DaySearch == "YES" then
		DaySearch = "NO"
		
		for i,v in ipairs(EpicTable) do
			day = EpicTable[i]["Day of Week"]

			if wnext == day then
				CheckLowest(i)
			end
		end

		if lowestindex > 0 then
			day = GetLowestDay(lowestindex)
			nexttype = "day"
			DisplayNext(nexttype, day, lowestindex)
		else
			nexttype = "day"
			day = wnext
			DisplayNextFail(nexttype, day, wnext)
		end

	elseif LeaderSearch == "YES" then
		LeaderSearch = "NO"

		for i,v in ipairs(EpicTable) do
			local search = EpicTable[i]["Epic Leader"]
		
			len = string.len(wnext)

			for j,k in pairs(string.split(search," ")) do
				if string.find(string.sub(k,1,len),wnext) ~= nil then
					CheckLowest(i)
				end
			end
		end
		
		if lowestindex > 0 then
			day = GetLowestDay(lowestindex)			
			nexttype = "leader"
			DisplayNext(nexttype, day, lowestindex)
		else
			nexttype = "leader"
			DisplayNextFail(nexttype, day, wnext)
		end
	else	
		if wnext == "epic" or wnext == nil then
			for i, v in ipairs(EpicTable) do
				CheckLowest(i)
			end

			if lowestindex > 0 then
				day = GetLowestDay(lowestindex)
				
				nexttype = "epic"
				DisplayNext(nexttype, day, lowestindex)
			else
				nexttype = "epic"
				DisplayNextFail(nexttype, day, wnext)
			end
		else
			wnext = string.lower(wnext)
			wnext = CheckType(wnext)

			len = string.len(wnext)

			for i,v in ipairs(EpicTable) do
				epicname = EpicTable[i]["Epic Name"]

				if string.find(string.sub(epicname,1,len),wnext) ~= nil then		
					CheckLowest(i)
				end
			end
	
			if lowestindex > 0 then
				day = GetLowestDay(lowestindex)				
				nexttype = "search"
				DisplayNext(nexttype, day, lowestindex)
			else
				nexttype = "search"
				DisplayNextFail(nexttype, day, wnext)
			end
		end
	end
end -- NextEpic

function DisplayNext(nexttype, day, lowestindex)
	ReturnType = "VI"
	timeremaining = EpicTimeDifference(lowestindex, ReturnType)

	if EpicTable[lowestindex]["Epic Name"] == "icefall1" then
		ename = "Icefall 1"
	elseif EpicTable[lowestindex]["Epic Name"] == "icefall2" then
		ename = "Icefall 2"
	elseif EpicTable[lowestindex]["Epic Name"] == "oc" then
		ename = "OC"
	else
		if EpicTable[lowestindex]["Epic Name"] ~= nil then
			ename = string.gsub (EpicTable[lowestindex]["Epic Name"], "^.", string.upper)
		end
	end

	eleader = EpicTable[lowestindex]["Epic Leader"]
	eleader = string.gsub (eleader, "^.", string.upper)

	if EpicMisc["TypeTime"] == "USER" then
		if reportchannel == nil then
			hour, tzdayindex = TimeZoneEpicHour(lowestindex)
			day = DaysofWeek[tzdayindex]
			day = string.gsub (day, "^.", string.upper)
		else
			hour = EpicHour(lowestindex)
		end
	elseif EpicMisc["TypeTime"] == "SERVER" then
		hour = EpicHour(lowestindex)
	end
	
	if nexttype == "day" then
		if EpicMisc["VI"] == "NO" then
			if reportchannel == nil then
				note = {epiccalcolour, "", "[EpicCAL] ", "red", "", "[", "yellow", "", day, msg_colour, "", "'s First Epic: ", "cyan", "", ename}
			else
				message = "@R[EpicCAL] [@Y" .. day .. "@D's First Epic: @C" .. ename
			end
		else
			if reportchannel == nil then
				note = {epiccalcolour, "", "EpicCAL ", "yellow", "", day, msg_colour, "", "'s First Epic: ", "cyan", "", ename}
			else
				message = "@REpicCAL @Y" .. day .. "@D's First Epic: @C" .. ename
			end
		end
	elseif nexttype == "leader" then
		if EpicMisc["VI"] == "NO" then
			if reportchannel == nil then
				note = {epiccalcolour, "", "[EpicCAL] ", "red", "", "[", "yellow", "", eleader, msg_colour, "", "'s Next Epic ", "cyan", "", ename, msg_colour, "", " / ", "red", "", day}
			else
				message = "@R[EpicCAL] [@Y" .. eleader .. "@D's Next Epic: @C" .. ename .. " @D/ @R" .. day
			end
		else
			if reportchannel == nil then
				note = {epiccalcolour, "", "EpicCAL ", "yellow", "", eleader, msg_colour, "", "'s Next Epic ", "cyan", "", ename, msg_colour, "", " Day: ", "red", "", day}
			else
				message = "@REpicCAL @Y" .. eleader .. "@D's Next Epic: @C" .. ename .. " @DDay: @R" .. day
			end
		end
	elseif nexttype == "search" then
		if EpicMisc["VI"] == "NO" then		
			if reportchannel == nil then
				note = {epiccalcolour, "", "[EpicCAL] ", "red", "", "[", msg_colour, "", "Next ", "cyan", "", ename, msg_colour, "", " / ", "red", "", day}
			else
				message = "@R[EpicCAL] [@DNext @C" .. ename .. "@D/ @R" .. day
			end
		else
			if reportchannel == nil then
				note = {epiccalcolour, "", "EpicCAL ", msg_colour, "", "Next ", "cyan", "", ename, msg_colour, "", " - ", msg_colour, "", "Day: ", "red", "", day}
			else
				message = "@REpicCAL @DNext @C" .. ename .. " @DDay: @R" .. day
			end
		end
	elseif nexttype == "epic" then
		if EpicMisc["VI"] == "NO" then			
			if reportchannel == nil then
				note = {epiccalcolour, "", "[EpicCAL] ", "red", "", "[", msg_colour, "", "Next Epic: ", "cyan", "", ename, msg_colour, "", " - ", "red", "", day}
			else
				message = "@R[EpicCAL] [@DNext Epic: @C" .. ename .. " @D- @R" .. day
			end
		else
			if reportchannel == nil then
				note = {epiccalcolour, "", "EpicCAL ", msg_colour, "", "Next Epic: ", "cyan", "", ename, msg_colour, "", " Day: ", "red", "", day}
			else
				message = "@REpicCAL @DNext Epic: @C" .. ename .. " @DDay: @R" .. day
			end
		end
	end

	if EpicTable[lowestindex]["Approx"] == "YES" then 
		apxhour = "* "
	else
		apxhour = " "
	end
	
	if reportchannel == nil then		
			table.insert(note, msg_colour)
			table.insert(note, "")
		if EpicMisc["VI"] == "NO" then
			table.insert(note, " / ")
		else
			table.insert(note, " Hour: ")
		end

		table.insert(note, "green")
		table.insert(note, "")
		table.insert(note, hour)

		if apxhour ~= "" then
			table.insert(note, "red")
			table.insert(note, "")
			table.insert(note, apxhour)
		end

			table.insert(note, msg_colour)
			table.insert(note, "")
		if EpicMisc["VI"] == "NO" then			
			table.insert(note, "/ ")
		else
			table.insert(note, "Time to Start: ")
		end
		table.insert(note, "lime")
		table.insert(note, "")
		
		if timeremaining ~= nil then
			table.insert(note, trim(timeremaining))
		end
		
		if EpicMisc["VI"] == "NO" then			
			table.insert(note, "red")
			table.insert(note, "")
			table.insert(note, "]")
		end
		
		ColourNote(unpack(note))
		Note("")
	else 
		if timeremaining ~= nil then
			timeremaining = trim(timeremaining)
		end
		
		if EpicMisc["VI"] == "NO" then			
			message = message .. " @D/ @Y" .. hour .. "@R" .. apxhour .. "@D/ @G" .. timeremaining  .. "@R]@w"
		else
			message = message .. " @DHour: @Y" .. hour .. "@R" .. apxhour .. " @DTime to Start: @G" .. timeremaining  .. "@w"
		end
		
		SendNoEcho(reportchannel .. " " .. message)
		reportchannel = nil	
	end
end -- DisplayNext

function DisplayNextFail(nexttype, day, wnext)
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	else
		if wnext == "epic" or wnext == nil then
			if nexttype == "day" then
				endnote = " for that day."
			elseif nexttype == "leader" then
				endnote = " for that leader."
			elseif nexttype == "search" or nexttype == "epic" then
				endnote = "."
			end
			
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "There are no epic runs scheduled " .. endnote)
			Note("")
		else
			if nexttype == "day" or nexttype == "leader" then
				if nexttype == "day" then
					for i,v in ipairs(DaysofWeekShort) do
						if day == DaysofWeekShort[i] then
							sendwhat = DaysofWeek[i]
						end
					end
				elseif nexttype == "leader" then
					sendwhat = wnext
				end

				if reportchannel == nil then
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "There are no epic runs scheduled for ", qty_colour, "", sendwhat, msg_colour, "", ".")
					Note("")
				else
					SendNoEcho (reportchannel .. " @R[EpicCAL] @DThere are no epic runs scheduled for @C" .. sendwhat .. "@D.@w")
					reportchannel = nil
				end
			elseif nexttype == "epic" or nexttype == "search" then			
				if wnext == "icefall1" then
					wnext = "Icefall 1"
				elseif wnext == "icefall2" then
					wnext = "Icefall 2"
				elseif wnext == "oc" then
					wnext = "OC"
				else
					if wnext ~= nil then
						wnext = string.gsub (wnext, "^.", string.upper)
					end
				end

				if reportchannel == nil then
					ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "There are no ", qty_colour, "", wnext, msg_colour, "", " epic runs scheduled.")
					Note("")
				else
					SendNoEcho (reportchannel .. " @R[EpicCAL] @DThere are no @C" .. wnext .. " @Depic runs scheduled.@w")
					reportchannel = nil
				end	
			end
		end
	end
end -- DisplayNextFail

----------------------------------------------
------- APPROXIMATE RUN TIME FUNCTIONS -------
----------------------------------------------
function AddRemoveEditRunTime(rcmd, rtname, rttime)
	rttime = tonumber(rttime)
	rttime = math.floor(rttime)
	
	if rttime < 5 then 
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Approximate run time can not be below ", qty_colour, "", "5", msg_colour, "", " minutes.")
		Note("")
		
		return
	end
	
	if rcmd == "add" then
		if EpicMisc["ApproxRunTimes"][rtname] == nil then
			EpicMisc["ApproxRunTimes"][rtname] = rttime
			
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Approximate run time for ", qty_colour, "", rtname, msg_colour, "", " has been set to ", qty_colour, "", rttime, msg_colour, "", " minutes.")
			Note("")
			
			SaveState()
			RunTimeUpdate()
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "The approximate run time for ", qty_colour, "", rtname, msg_colour, "", " has already been added and set to ", qty_colour, "", EpicMisc["ApproxRunTimes"][rtname], msg_colour, "", " minutes. If you wish to change this please type ecal rt edit ", qty_colour, "", rtname, msg_colour, "", " <minutes>")
			Note("")
		end
	elseif rcmd == "remove" then
		if EpicMisc["ApproxRunTimes"][rtname] == nil then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", rtname, msg_colour, "", " has not been added to the approximate run time list. For a complete list please use ", qty_colour, "", "ecal rt list", msg_colour, "", ".")
			Note("")
		else		
			EpicMisc["ApproxRunTimes"][rtname] = nil
			
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Approximate run time for ", qty_colour, "", rtname, msg_colour, "", " has been removed from the list.")
			Note("")
			
			SaveState()
			RunTimeUpdate()
		end
	elseif rcmd == "edit" then
		if rtname == "if1" then rtname = "icefall1" end
		if rtname == "if2" then rtname = "icefall2" end
		if rtname == "transcend" or rtname == "ts" then rtname = "transcendence" end
		
		if EpicMisc["ApproxRunTimes"][rtname] == nil then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", rtname, msg_colour, "", " has not been added to the approximate run time list. For a complete list please use ", qty_colour, "", "ecal rt list", msg_colour, "", ".")
			Note("")
		else		
			EpicMisc["ApproxRunTimes"][rtname] = rttime
			
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Approximate run time for ", qty_colour, "", rtname, msg_colour, "", " has been set to ", qty_colour, "", rttime, msg_colour, "", " minutes.")
			Note("")
			
			SaveState()
			RunTimeUpdate()
		end
	end
end -- AddRemoveEditRunTime

function RunTimeUpdate()
	check (EnableTimer ("autonodelay", 1))
	check (ResetTimer ("autonodelay"))
	world.EnableGroup ("RTUpdateCommands", 1)
	
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Changes will not take affect until you reset the epic list.")
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Would you like to do that now? ", qty_colour, "", "(yes/no)")
	Note("")
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Will auto reply ", qty_colour, "", "NO", msg_colour, "", " in ", qty_colour, "", "10", msg_colour, "", " seconds.")
	Note("")
end -- RunTimeUpdate

function RTUpdateYes()
	RunTimeUpdateEnd()
	ResetEpicTable()
	resetcheck = "YES"
end -- RTUpdateYes

function RTUpdateNo()
	RunTimeUpdateEnd()
	
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Epic List has not been updated. Please type ", qty_colour, "", "ecal reset", msg_colour, "", " to see changes to run times.")
	Note("")
end -- RTUpdateNo

function RunTimeUpdateEnd()
	world.EnableGroup ("RTUpdateCommands", 0)	
	check (EnableTimer ("autonodelay", 0))
end -- RunTimeUpdateEnd

function ListRunTimes()
	title = "Approximate Epic Run Time List"

	local title2 = "+-----------------+------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)

	if EpicMisc["VI"] == "NO" then
		Note("")
		ColourNote(msg_colour, "", title2)	
		ColourNote(msg_colour, "", "| Epic Name       | Approx. RT |")
		ColourNote(msg_colour, "", title2)
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end
	
	IndexedApproxTable = {}

	for k, v in pairs(EpicMisc["ApproxRunTimes"]) do
		if k ~= "Grouping Time" then
			table.insert(IndexedApproxTable, {["Name"]=k, ["Time"]=v})
		end
	end
	
	table.sort(IndexedApproxTable, function (a, b) return a["Name"] < b["Name"] end)

	for i,v in ipairs(IndexedApproxTable) do

		epicname = IndexedApproxTable[i]["Name"]
		
		runtime = tonumber(IndexedApproxTable[i]["Time"])
		
		epicname = string.gsub (epicname, "^.", string.upper)
		
		if epicname == "Icefall1" then epicname = "Icefall 1" end
		if epicname == "Icefall2" then epicname = "Icefall 2" end
		if epicname == "Oc" then epicname = "OC" end
		
		if epicname == nil then enamespace = 15 else enamespace = MakeSpace(epicname, 15) end
		if runtime == nil then rtspace = 2 else rtspace = MakeSpace(runtime, 2) end
		

		if EpicMisc["VI"] == "NO" then
			ColourNote(msg_colour, "", "| ", epic_colour, "", epicname .. enamespace, msg_colour, "", " | ", leader_colour, "", rtspace .. runtime .. " minutes", msg_colour, "", " | ")
		elseif EpicMisc["VI"] == "YES" then
			ColourNote(msg_colour, "", "Epic Name: ", epic_colour, "", epicname, msg_colour, "", " Approximate Run Time: ", leader_colour, "", runtime .. " minutes")
		end	
	end

	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	end
	
	Note("")

	gttime = EpicMisc["ApproxRunTimes"]["Grouping Time"]["Time"]
	
	if EpicMisc["ApproxRunTimes"]["Grouping Time"]["Enabled"] == false then
		gtstatus = "Disabled"
		gtcolour = "red"
		factormessage = "will not"
	elseif EpicMisc["ApproxRunTimes"]["Grouping Time"]["Enabled"] == true then
		gtstatus = "Enabled"
		gtcolour = "green"
		factormessage = "will"
	end

	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Grouping Time is set to ", "red", "", gttime, msg_colour, "", " minute(s)")
	Note("")
	
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Grouping Time is currently ", gtcolour, "", gtstatus, msg_colour, "", ". Approximate start times ", gtcolour, "", factormessage, msg_colour, "", " factor in grouping time.")
	Note("")
end -- ListRunTimes
 
---------------------------------------------
--------------- BOT FUNCTIONS ---------------
---------------------------------------------
function EpicBotStatus()
	if EpicMisc["NotificationBot"]["Enabled"] == false then
		sysstatus = "Disabled"
		syscolour = "red"
	elseif EpicMisc["NotificationBot"]["Enabled"] == true then
		sysstatus = "Enabled"
		syscolour = "green"
	end

	ColourNote(msg_colour, "", "Epic Calendar Notification System - ", syscolour, "", sysstatus)
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", "--------------------------------------------")
	else
		Note("")
	end
	

	if EpicMisc["NotificationBot"]["AlertEnabled"] == false then
		sysstatus = "Disabled"
		syscolour = "red"
	elseif EpicMisc["NotificationBot"]["AlertEnabled"] == true then
		sysstatus = "Enabled"
		syscolour = "green"
	end

	ColourNote(msg_colour, "", "Upcoming Epic Alert System - ", syscolour, "", sysstatus)
	Note("")

	cmd = "auto"
	ListChannels(cmd)

	cmd = "commands"
	ListChannels(cmd)
	
end -- EpicBotStatus

function BotHelp(channel, user, cmd)
	if cmd == "nextepic" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!nextepic <epic> @D- displays when the next specified epic is scheduled. Using @C!nextepic @Don its own will display the next scheduled epic. Note: @R*@D next to the time indiciates an approximate start time, actual start time may vary.@w")
	elseif cmd == "nextday" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!nextday <day> @D- displays the first epic of the day on that particular day. Note: @R*@D next to the time indiciates an approximate start time, actual start time may vary.@w")
	elseif cmd == "nextleader" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!nextleader <leader> @D- displays the first epic scheduled for that particular leader. Note: @R*@D next to the time indiciates an approximate start time, actual start time may vary.@w")
	elseif cmd == "listepic" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!listepic @D- displays the entire epic schedule on one line sorted by day. @C!listepic leader @Dand @C!listepic epic @Dwill display the schedule but grouped together. @C!listepic <epic name> @Dwill display only that particular epic. And finally @C!listepic note @Dwill send the schedule to the user via a note. Note: @R*@D next to the time indiciates an approximate start time, actual start time may vary.@w")
	elseif cmd == "listday" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!listday @D- displays the entire epic schedule for today. @C!listday <day> @Dwill display the full schedule for that paritcular day. Note: @R*@D next to the time indiciates an approximate start time, actual start time may vary.@w")
	elseif cmd == "listleader" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!listday <leader> @D- displays the entire epic schedule for that particular leader.@w")
	elseif cmd == "noteremove" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!noteremove <notenum> @D- will request the bot to remove the schedule note@w")
	else
		user = string.gsub (user, "^.", string.upper)
		SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D, that is not a valid option.@w")
	end
end -- BotHelp
	
function AutoAddRemoveChannel(cmd, channel)	
	if cmd == "add" then
		if channel ~= nil then
			if EpicMisc["NotificationBot"]["Auto"][channel] == nil then
				ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", channel, msg_colour, "", " channel has been added to the auto notification list and has been set to off by by default")
				Note("")
				EpicMisc["NotificationBot"]["Auto"][channel] = false
			else
				ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", channel, msg_colour, "", " has already been added to the auto notification list")
				Note("")
			end
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Please specify which channel you would like to add.")
			Note("")
		end
	elseif cmd == "remove" then
		if channel ~= nil then
			if EpicMisc["NotificationBot"]["Auto"][channel] == nil then
				ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", channel, msg_colour, "", " was not on the auto notification list")
				Note("")
			else
				ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", channel, msg_colour, "", " channel has been removed from the auto notification list")
				Note("")
				EpicMisc["NotificationBot"]["Auto"][channel] = nil
			end
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Please specify which channel you would like to remove.")
			Note("")
		end
	end
	
	SaveState()
end -- AutoAddRemoveChannel

function ListPermissions()
	local plist = 0

	for i,v in pairs (EpicPermissionTable) do 
		if EpicPermissionTable[i]["Since"] ~= nil then
			plist = plist + 1
		end
	end

	if plist == 0 then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "There are currently no users added to the permission's list")
		return
	end

	title = "Bot Permissions List"
	
	local title2 = "+--------------+--------------------------------+--------------------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
		ColourNote(msg_colour, "", "| Name         | On List Since                  | Time on List                               |")
		ColourNote(msg_colour, "", title2)
	end
	
	IndexedEpicPermissionTable = {}

	for k, v in pairs(EpicPermissionTable) do
		table.insert(IndexedEpicPermissionTable, {["Name"]=k, ["Since"]=v["Since"]})
	end

	table.sort(IndexedEpicPermissionTable, function (a, b) local atime = os.time(a["Since"]); local btime = os.time(b["Since"]); if atime == btime then return a["Name"] > b["Name"] else return atime > btime end end)

	for i,v in ipairs(IndexedEpicPermissionTable) do

		user = string.gsub (IndexedEpicPermissionTable[i]["Name"], "^.", string.upper)
		since = os.date ("%a, %d %b %Y - %I:%M:%S %p", os.time(IndexedEpicPermissionTable[i]["Since"]))
		
		local timenow = os.time()
		local timenow2 = os.time(IndexedEpicPermissionTable[i]["Since"])
		
		local timediff2 = {}

		timeDiff(timenow,timenow2,timediff2)

		local timeonlist = remainingtime_noteVI(timediff2)
		
		if user == nil then namespace = 12 else namespace = MakeSpace(user, 12) end
		
		if since == nil then sincespace = 30 else sincespace = MakeSpace(since, 30) end
		
		if timeonlist == nil then onlistspace = 42 else onlistspace = MakeSpace(timeonlist, 42) end

		if EpicMisc["VI"] == "NO" then
			ColourNote(msg_colour, "", "| ", epic_colour, "", user .. namespace, msg_colour, "", " | ", leader_colour, "", since .. sincespace, msg_colour, "", " | ", remain_colour, "", timeonlist .. onlistspace, msg_colour, "", " |")
		elseif EpicMisc["VI"] == "YES" then
			ColourNote(epic_colour, "", user, msg_colour, "", " Added: ", leader_colour, "", since .. sincespace, msg_colour, "", " Time on list: ", remain_colour, "", timeonlist .. onlistspace)		
		end
	end
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	end
	
	Note("")
end -- ListPermissions

function ListChannels(cmd)
	if cmd == "auto" then
		title = "Auto Notification Channels"
		display = "Auto"
		sysname = "AutoEnabled"
	elseif cmd == "commands" then
		title = "Channel Commands System"
		display = "Commands"
		sysname = "CommandsEnabled"
	end
	
	local title2 = "+---------+----------+"
	
	spacing = HelpSpacing(title, title2)
	
	syscolour = msg_colour
	sysstatus = ""
		
	if EpicMisc["NotificationBot"][sysname] == false then
		sysstatus = "Disabled"
		syscolour = "red"
	elseif EpicMisc["NotificationBot"][sysname] == true then
		sysstatus = "Enabled"
		syscolour = "green"
	end
	
	ColourNote(msg_colour, "", spacing, msg_colour, "", title, help_colour, "", " - ", syscolour, "", sysstatus)
	Note("")

	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
		ColourNote(msg_colour, "", "| Channel |  Status  |")
		ColourNote(msg_colour, "", title2)
	end
	
	for i, v in pairs(EpicMisc["NotificationBot"][display]) do
		if v == false then
			display_colour = "red" 
			displayname = "OFF"
		elseif v == true then
			display_colour = "green"
			displayname = "ON"
		end
	
		if i == nil then channelspace = 7 else channelspace = MakeSpace(i, 7) end
		
		if display == nil then displayspace = 3 else displayspace = MakeSpace(displayname, 3) end
		
		if EpicMisc["VI"] == "NO" then
			ColourNote(msg_colour, "", "| ", epic_colour, "", i .. channelspace, msg_colour, "", " |   ", display_colour, "", displayname .. displayspace, msg_colour, "", "    | ")
		elseif EpicMisc["VI"] == "YES" then
			ColourNote(msg_colour, "", "Channel: ", epic_colour, "", i .. channelspace, msg_colour, "", " Status: ", display_colour, "", displayname .. displayspace)
		end
	end
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	end

	Note("")
	
	if cmd == "commands" then
		permissions = string.upper(EpicMisc["NotificationBot"]["Permissions"])
	
		ColourNote(msg_colour, "", "Channel Command Permissions set to ", qty_colour, "", permissions)
	end
end -- ListChannels

function UserPermission(cmd, user)		
	if cmd == "add" then
		addcheck = "NO"
		
		for i,v in pairs(EpicPermissionTable) do			
			if i == user then
				addcheck = "YES"
			end
		end
		
		if addcheck == "NO" then
			EpicPermissionTable[user] = {}
			EpicPermissionTable[user]["Since"] = os.date("*t")
			user = string.gsub (user, "^.", string.upper)
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has been granted access to the bot commands.")	
			Note("")
		elseif addcheck == "YES" then
			user = string.gsub (user, "^.", string.upper)
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has already been granted access.")
			Note("")
		end
	elseif cmd == "remove" then
		addcheck = "NO"

		for i,v in pairs(EpicPermissionTable) do
			if i == user then 
				EpicPermissionTable[user] = nil
				addcheck = "YES"
				user = string.gsub (user, "^.", string.upper)
				ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", "'s bot command access has been removed.")
				Note("")
				return
			end
		end
		
		if addcheck == "NO" then
			user = string.gsub (user, "^.", string.upper)
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " was not on found in access list.")
			Note("")
		end
	end
	
	SaveState()
end -- UserPermission
 
function TogglePermissions()
	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel commands permissions set to ", qty_colour, "", "ALL")
		Note("")
		EpicMisc["NotificationBot"]["Permissions"] = "all"
	elseif EpicMisc["NotificationBot"]["Permissions"] == "all" then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel commands permissions set to ", qty_colour, "", "LIST")
		Note("")
		EpicMisc["NotificationBot"]["Permissions"] = "list"
	end

	SaveState()
end -- TogglePermissions

function EnableBot()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Epic Notification Bot enabled.")
	Note("")
	EpicMisc["NotificationBot"]["Enabled"] = true

	SaveState()

	if EpicMisc["NotificationBot"]["CommandsEnabled"] == true then
		EnableCommandBot()
	end

	if EpicMisc["NotificationBot"]["AlertEnabled"] == true then
		EnableAlertBot()
	end
	
	if EpicMisc["NotificationBot"]["AutoEnabled"] == true then
		EnableAutoBot()
	end
end -- EnableBot

function DisableBot()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Epic Notification Bot disabled.")
	Note("")
	EpicMisc["NotificationBot"]["Enabled"] = false

	SaveState()

	if EpicMisc["NotificationBot"]["CommandsEnabled"] == true then
		DisableCommandBot()
	end

	if EpicMisc["NotificationBot"]["AlertEnabled"] == true then
		DisableAlertBot()
	end
	
	if EpicMisc["NotificationBot"]["AutoEnabled"] == true then
		DisableAutoBot()
	end	
end -- DisableBot

function EnableAlertBot()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Alert System Enabled. You will now be notified roughly 1 hour in advance of any upcoming epic runs.")
	Note("")
		
	if TableFilled == "YES" then
		AlertCheck()
	end
end -- EnableAlertBot

function DisableAlertBot()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Alert System Disabled. You will now no longer be notified in advance of any upcoming epic runs.")
	Note("")
end -- DisableAlertBot

function EnableAutoBot()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Automatic Next Epic Notifications Enabled.")
	Note("")
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You will now broadcast hourly the next upcoming epic run on channels you have enabled.")
	Note("")
	
	check (EnableTimer ("HourlyNextEpicNotification", 1))
	check (ResetTimer ("HourlyNextEpicNotification"))	
end -- EnableAutoBot

function DisableAutoBot()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Automatic Next Epic Notifications Disabled.")
	Note("")
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You will longer broadcast the next upcoming epic run.")
	Note("")
	
	check (EnableTimer ("HourlyNextEpicNotification", 0))	
end	 -- DisableAutoBot

function EnableCommandBot()
	if EpicMisc["BlacklistEnabled"] == true then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel Command Bot enabled and privileges set to ", qty_colour, "", string.upper(EpicMisc["NotificationBot"]["Permissions"]), msg_colour, "", ". Blacklist is ", qty_colour, "", "ON.")
	else
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel Command Bot enabled and privileges set to ", qty_colour, "", string.upper(EpicMisc["NotificationBot"]["Permissions"]), msg_colour, "", ". Blacklist is ", qty_colour, "", "OFF.")
	end

	Note("")
	
	if EpicMisc["NotificationBot"]["Commands"]["gt"] == true then
		EnableTrigger ("GroupChannel", true)
	elseif EpicMisc["NotificationBot"]["Commands"]["gt"] == false then
		EnableTrigger ("GroupChannel", false)
	end
	
	if EpicMisc["NotificationBot"]["Commands"]["spouse"] == true then
		EnableTrigger ("SpouseChannel", true)
		EnableTrigger ("SpouseChannelYou", true)
	elseif EpicMisc["NotificationBot"]["Commands"]["spouse"] == false then
		EnableTrigger ("SpouseChannel", false)
		EnableTrigger ("SpouseChannelYou", false)
	end
	
	if EpicMisc["NotificationBot"]["Commands"]["tell"] == true then
		EnableTrigger ("TellChannel", true)
	elseif EpicMisc["NotificationBot"]["Commands"]["tell"] == false then
		EnableTrigger ("TellChannel", false)
	end

	if EpicMisc["NotificationBot"]["Commands"]["ft"] == true then
		EnableTrigger ("FriendChannel", true)
		EnableTrigger ("FriendChannelYou", true)
	elseif EpicMisc["NotificationBot"]["Commands"]["ft"] == false then
		EnableTrigger ("FriendChannel", false)
		EnableTrigger ("FriendChannelYou", false)
	end

	if EpicMisc["NotificationBot"]["Commands"]["clan"] == true then
		EnableTrigger ("ClanChannel", true)
		EnableTrigger ("ClanChannelYou", true)
	elseif EpicMisc["NotificationBot"]["Commands"]["clan"] == false then
		EnableTrigger ("ClanChannel", false)
		EnableTrigger ("ClanChannelYou", false)
	end	
end -- EnableCommandBot

function DisableCommandBot()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel Commands System has been ", "red", "", "Disabled.")
	Note("")
	
	EnableTrigger ("GroupChannel", false)
	EnableTrigger ("SpouseChannel", false)
	EnableTrigger ("SpouseChannelYou", false)
	EnableTrigger ("TellChannel", false)
	EnableTrigger ("FriendChannel", false)
	EnableTrigger ("ClanChannel", false)
	EnableTrigger ("ClanChannelYou", false)
	EnableTrigger ("FriendChannelYou", false)
end -- DisableCommandBot

function ChannelCommandEnable(channel)
	EpicMisc["NotificationBot"]["Commands"][channel] = true

	if EpicMisc["NotificationBot"]["Enabled"] == true then
		if EpicMisc["NotificationBot"]["CommandsEnabled"] == true then
			if channel == "ft" then
				EnableTrigger ("FriendChannel", true)
				EnableTrigger ("FriendChannelYou", true)
			elseif channel == "clan" then
				EnableTrigger ("ClanChannel", true)
				EnableTrigger ("ClanChannelYou", true)
			elseif channel == "gt" then
				EnableTrigger ("GroupChannel", true)
			elseif channel == "tell" then
				EnableTrigger ("TellChannel", true)
			elseif channel == "spouse" then
				EnableTrigger ("SpouseChannel", true)
				EnableTrigger ("SpouseChannelYou", true)
			end
			
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel commands for ", qty_colour, "", channel, msg_colour, "", " channel have been ", "green", "", "Enabled.")
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel commands for ", qty_colour, "", channel, msg_colour, "", " channel have been ", "green", "", "Enabled.", msg_colour, "", " The Channel Commands system is currently ", "red", "", "Disabled", msg_colour, "", ". Please type ", qty_colour, "", "ecal bot commands enable", msg_colour, "", " to use this feature.")
		end
	else
		if EpicMisc["NotificationBot"]["CommandsEnabled"] == true then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel commands for ", qty_colour, "", channel, msg_colour, "", " channel have been ", "green", "", "Enabled.", msg_colour, "", " The Notification Bot is currently ", "red", "", "Disabled", msg_colour, "", ". Please type ", qty_colour, "", "ecal bot enable", msg_colour, "", " to use this feature.")
		else
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel commands for ", qty_colour, "", channel, msg_colour, "", " channel have been ", "green", "", "Enabled.", msg_colour, "", " Both Notification Bot and Channel Commands system are currently ", "red", "", "Disabled", msg_colour, "", ". Enable both to use this feature.")
		end
	end
	
	Note("")
	
	SaveState()
end -- ChannelCommandEnable

function ChannelCommandDisable(channel)
	EpicMisc["NotificationBot"]["Commands"][channel] = false

	if EpicMisc["NotificationBot"]["Enabled"] == true then
		if EpicMisc["NotificationBot"]["CommandsEnabled"] == true then
			if channel == "ft" then
				EnableTrigger ("FriendChannel", false)
				EnableTrigger ("FriendChannelYou", false)
			elseif channel == "clan" then
				EnableTrigger ("ClanChannel", false)
				EnableTrigger ("ClanChannelYou", false)
			elseif channel == "gt" then
				EnableTrigger ("GroupChannel", false)
			elseif channel == "tell" then
				EnableTrigger ("TellChannel", false)
			elseif channel == "spouse" then
				EnableTrigger ("SpouseChannel", false)
				EnableTrigger ("SpouseChannelYou", false)
			end

			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Channel commands for ", qty_colour, "", channel, msg_colour, "", " channel have been ", "red", "", "Disabled.")
		end
	end
	
	Note("")	
	
	SaveState()
end -- ChannelCommandDisable
	
function ChannelBot(user, cmd, search, channel)	
	if search == "if1" or search == "icefall 1" then search = "icefall1" end
	if search == "if2" or search == "icefall 2" then search = "icefall2" end
	if search == "transcend" or search == "ts" then search = "transcendence" end
	
	if CheckChannel(channel) == "no" then
		if CheckChannelUnapproved(channel) == "yes" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Can not post to that channel.")
			
			return
		end
	end

	GetCharName()
	
	if search ~= nil and search ~= "" then 
		if cmd == "nextepic" then
			Execute("ecal next " .. search .. " " .. channel)
		elseif cmd == "listday" then
			if search == "today" then
				search = listdayvar
			elseif search == "tomorrow" then
				search = listdayvartomorrow
			end
			
			ChannelListDay(channel, search)
		elseif cmd == "listleader" then
			ChannelListLeader(channel, search)
		elseif cmd == "listepic" or cmd == "listepics" or cmd == "epiclist" then
			if search == "note" then
				if user ~= nil then
					if user == charname then
						SendNoEcho (channel .. " @R[EpicCAL] @DSorry, type @Cecal list @Dinstead of sending a note to yourself.@w")

						return
					elseif (CheckRoom()) == "no" then
						user = string.gsub (user, "^.", string.upper)
						SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D, I can not complete your request at this time Reason: @CI am not in a designated note safe room. Please try again later.@w")

						return
					end
				
					noteuser = user
					StartPost()
				end
			elseif search == "today" then
				search = listdayvar
				
				ChannelListDay(channel, search)
			elseif search == "tomorrow" then
				search = listdayvartomorrow
				
				ChannelListDay(channel, search)
			else
				ChannelListEpic(channel, search)
			end
		elseif cmd == "noteremove" then
			if tonumber(search) ~= nil then
				nnum = tonumber(search)
				SendNoEcho ("board personal")
				SendNoEcho ("note remove " .. nnum)
			end
		elseif cmd == "update" then
			ResetEpicTable()
			resetchannel = channel
		elseif cmd == "help" then
			BotHelp(channel, user, search)
		else
			Execute("ecal " .. cmd .. " " .. search .. " " .. channel)
		end
	else
		if cmd == "nextepic" then
			Execute("ecal next epic " .. channel)
		elseif cmd == "nextleader" then
			user = string.gsub (user, "^.", string.upper)
			SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D command usage is @C!nextleader <leader name>@w")
		elseif cmd == "nextday" then
			user = string.gsub (user, "^.", string.upper)
			SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D command usage is @C!nextday <day>@w")			
		elseif cmd == "listday" then
			search = nil
			ChannelListDay(channel, search)
		elseif cmd == "listleader" then
			user = string.gsub (user, "^.", string.upper)
			SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D command usage is @C!listleader <leader>@w")
		elseif cmd == "listepic" or cmd == "listepics" or cmd == "epiclist" then
			search = nil
			ChannelListEpic(channel, search)
		elseif cmd == "noteremove" then
			user = string.gsub (user, "^.", string.upper)
			SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D, Which note did you want me to remove?")
		elseif cmd == "update" then
			ResetEpicTable()
			resetchannel = channel
		elseif cmd == "help" then
			user = string.gsub (user, "^.", string.upper)
			SendNoEcho (channel .. " @R[EpicCAL] @DHello @C" .. user .. "@D, available commands: @C!nextepic@D, @C!nextday@D, @C!nextleader@D, @C!listepic@D, @C!listday, !listleader @Dand @C!noteremove@D. Please see @C!help <cmd> @Dfor more information, i.e. @C!help nextepic@D.@w")
		end
	end	
end -- ChannelBot

function CheckOver(eindex)
	if EpicTable[eindex]["Time Table"]["year"] > SystemTimeTable["year"] then
		ocheck = "NO"
		return ocheck
	end
	
	if EpicTable[eindex]["Time Table"] == nil then 
		ocheck = "YES"
		return ocheck
	elseif EpicTable[eindex]["Time Table"]["yday"] == nil then 
		ocheck = "YES"
		return ocheck
	elseif EpicTable[eindex]["Time Table"]["hour"] == nil then 
		ocheck = "YES"
		return ocheck
	elseif EpicTable[eindex]["Time Table"]["min"] == nil then 
		ocheck = "YES"
		return ocheck
	end

	epicday = EpicTable[eindex]["Time Table"]["yday"]
	epichour = EpicTable[eindex]["Time Table"]["hour"]
	epicmin = EpicTable[eindex]["Time Table"]["min"]
	sysday = SystemTimeTable["yday"]
	syshour = SystemTimeTable["hour"]
	sysmin = SystemTimeTable["min"]
	
	ocheck = "NO"
	
	if epicday < sysday then
		ocheck = "YES"
		return ocheck
	elseif epicday == sysday then
		if epichour < syshour then
			ocheck = "YES"
			return ocheck
		elseif epichour == syshour then
			if epicmin < sysmin then
				ocheck = "YES"
				return ocheck
			end
		end
	end

	return ocheck
end -- CheckOver

function ChannelListDay(channel, day)
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end

	table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)
		
	if day == nil then		
		message = "@R[Full Schedule for @CToday@R] - "
		message2 = "@R[Full Schedule for @CToday@R] - "

		wday = SystemTimeTable["wday"]
	else
		echeck = "NO"

		for i, v in ipairs(DaysofWeekShort) do
			eday = v
			len = string.len(eday)

			if string.find(string.sub(day,1,len),eday) ~= nil then
				wday = i
				echeck = "YES"
			end
		end
		
		if echeck == "NO" then
			SendNoEcho (channel .. " @R[EpicCAL] @C" .. day .. " @Dis not a valid day.@w")
			return
		end
		
		day = string.gsub (day, "^.", string.upper)
		
		message = "@R[Full Schedule for @C" .. day .. "@R] - "
		message2 = "@R[Full Schedule for @C" .. day .. "@R] - "	
	end

	daycheck = "NO"

	for i,v in ipairs(EpicTable) do
		if CheckOver(i) == "NO" then
			previndex = i - 1		
			
			if EpicTable[i]["Epic Name"] == "icefall1" then
				ename = "Icefall 1"
			elseif EpicTable[i]["Epic Name"] == "icefall2" then
				ename = "Icefall 2"
			elseif EpicTable[i]["Epic Name"] == "oc" then
				ename = "OC"
			else 
				ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
			end
			
			dindex = EpicTable[i]["Time Table"]["wday"]
			
			day2 = string.gsub (DaysofWeekShort[dindex], "^.", string.upper)
			
			if EpicTable[i]["Approx"] == "YES" then 
				apxhour = "*"
			else
				apxhour = ""
			end

			hour = EpicHour(i)
			
			mindex = EpicTable[i]["Time Table"]["month"]
			month = string.gsub (Months[mindex], "^.", string.upper)
			
			date = month .. " " .. EpicTable[i]["Time Table"]["day"]
    	
			if wday == dindex then
				daycheck = "YES"
				if message == message2 then
					message = message .. "@R[@C" .. ename .. " @R- @G" .. hour .. "@R" .. apxhour
				else
					if EpicTable[i]["Time Table"]["yday"] == EpicTable[previndex]["Time Table"]["yday"] then
						message = message .. "@R/@C" .. ename .. " @R- @G" .. hour .. "@R" .. apxhour
					else
						message = message .. "@R] [@C" .. ename .. " @R- @G" .. hour .. "@R" .. apxhour
					end
				end
			end
		end
	end
	
	if daycheck == "YES" then
		SendNoEcho (channel .. " " .. message .. "@R]@w")
	elseif daycheck == "NO" then
		if day == nil then 
			SendNoEcho (channel .. " @DThere are no epics runs scheduled or left to run today.@w")
		else
			day = string.gsub (day, "^.", string.upper)
			SendNoEcho (channel .. " @DThere are no epics runs scheduled or left to run on @C" .. day .. "@D.@w")
		end
	end
end -- ChannelListDay

function ChannelListLeader(channel, leader)
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end

	table.sort(EpicTable, function (a, b) local aleader = a["Epic Leader"]; local bleader = b["Epic Leader"]; if aleader == bleader then return a["Index"] < b["Index"] else return aleader < bleader end end)
	
	eleader = string.gsub (leader, "^.", string.upper)
	
	message = "@R[Full Schedule for @C" .. eleader .. "@R] - "
	message2 = "@R[Full Schedule for @C" .. eleader .. "@R] - "	

	leadercheck = "NO"

	for i,v in ipairs(EpicTable) do
		if CheckOver(i) == "NO" then
			if leader == EpicTable[i]["Epic Leader"] then 
				previndex = i - 1		
				leadercheck = "YES"
				
				if EpicTable[i]["Epic Name"] == "icefall1" then
					ename = "Icefall 1"
				elseif EpicTable[i]["Epic Name"] == "icefall2" then
					ename = "Icefall 2"
				elseif EpicTable[i]["Epic Name"] == "oc" then
					ename = "OC"
				else 
					ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
				end
				
				dindex = EpicTable[i]["Time Table"]["wday"]
			
				day2 = string.gsub (DaysofWeekShort[dindex], "^.", string.upper)
				
				if EpicTable[i]["Approx"] == "YES" then 
					apxhour = "*"
				else
					apxhour = ""
				end

				hour = EpicHour(i)
			
				mindex = EpicTable[i]["Time Table"]["month"]
				month = string.gsub (Months[mindex], "^.", string.upper)
				
				date = month .. " " .. EpicTable[i]["Time Table"]["day"]
			
				if message == message2 then
					message = message .. "@R[@Y" .. date .. " @R- @C" .. ename .. " @G" .. hour .. "@R" .. apxhour
				else
					if EpicTable[i]["Time Table"]["yday"] == EpicTable[previndex]["Time Table"]["yday"] then
						message = message .. "@R/@C" .. ename .. " @G" .. hour .. "@R" .. apxhour
					else
						message = message .. "@R] [@Y" .. date .. " @R- @C" .. ename .. " @G" .. hour .. "@R" .. apxhour
					end
				end
			end
		end
	end
	
	if leadercheck == "YES" then
		SendNoEcho (channel .. " " .. message .. "@R]@w")
	elseif leadercheck == "NO" then
		SendNoEcho (channel .. " @R[EpicCAL] @C" .. leader .. " @Dhas no epic runs scheduled.@w")
	end
end -- ChannelListLeader

function ChannelListEpic(channel, ltype)
	if next (EpicTable) == nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		Note("")

		return
	end

	if ltype == nil then
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)
		
		message = "@R[Full Schedule] - "
		message2 = "@R[Full Schedule] - "
	elseif ltype == "epic" then
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if a["Epic Name"] == b["Epic Name"] then return atime < btime else return a["Epic Name"] < b["Epic Name"] end end)

		message = "@R[Full Schedule - Grouped by Epic Name] - "
		message2 = "@R[Full Schedule - Grouped by Epic Name] - "
	elseif ltype == "leader" then
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if a["Epic Leader"] == b["Epic Leader"] then return atime < btime elseif atime == btime then return a["Epic Leader"] < b["Epic Leader"] else return a["Index"] < b["Index"] end end)
		
		message = "@R[Full Schedule - Grouped by Leader] - "
		message2 = "@R[Full Schedule - Grouped by Leader] - "
	else
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if a["Epic Name"] == b["Epic Name"] then return atime < btime  else return a["Epic Name"] < b["Epic Name"] end end)
	
		if ltype == "icefall1" then
			sepic = "Icefall 1"
		elseif ltype == "icefall2" then
			sepic = "Icefall 2"
		elseif ltype == "oc" then
			sepic = "OC"
		else 
			sepic = string.gsub (ltype, "^.", string.upper)
		end

		message = "@R[Full Schedule - Epic Names matching @C" .. sepic .. "@R] - "
		message2 = "@R[Full Schedule - Epic Names matching @C" .. sepic .. "@R] - "
		
		echeck = "NO"
		
		for i,v in ipairs(EpicTable) do
			len = string.len(ltype)

			epicname = EpicTable[i]["Epic Name"]

			if string.find(string.sub(epicname,1,len),ltype) ~= nil then
				echeck = "YES"
			end
		end
		
		if echeck == "NO" then
			SendNoEcho (channel .. " @R[EpicCAL] @DNo @C" .. ltype .. " @Depic runs scheduled.@w")
			return
		end
	end
	
	for i,v in ipairs(EpicTable) do
		if CheckOver(i) == "NO" then
			previndex = i - 1		
			
			if EpicTable[i]["Epic Name"] == "icefall1" then
				ename = "Icefall 1"
			elseif EpicTable[i]["Epic Name"] == "icefall2" then
				ename = "Icefall 2"
			elseif EpicTable[i]["Epic Name"] == "oc" then
				ename = "OC"
			else 
				ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
			end
			
			dindex = EpicTable[i]["Time Table"]["wday"]
			
			day = string.gsub (DaysofWeekShort[dindex], "^.", string.upper)

			if EpicTable[i]["Approx"] == "YES" then 
				apxhour = "*"
			else
				apxhour = ""
			end

			hour = EpicHour(i)
		
			mindex = EpicTable[i]["Time Table"]["month"]
			month = string.gsub (Months[mindex], "^.", string.upper)
			
			date = month .. " " .. EpicTable[i]["Time Table"]["day"]
    	
			if ltype == nil then
				if message == message2 then
					message = message .. "@R[" .. day .. ": @C" .. ename .. " @G" .. hour .. "@R" .. apxhour
				else
					if EpicTable[i]["Time Table"]["yday"] == EpicTable[previndex]["Time Table"]["yday"] then
						message = message .. "@R/@C" .. ename .. " @G" .. hour .. "@R" .. apxhour
					else
						message = message .. "@R] [" .. day .. ": @C" .. ename .. " @G" .. hour .. "@R" .. apxhour
					end
				end
			elseif ltype == "epic" then
				if message == message2 then
					message = message .. "@R[" .. ename .. ": @C" .. day .. " (" .. date .. ") @R- @G" .. hour .. "@R" .. apxhour
				else
					if EpicTable[i]["Epic Name"] == EpicTable[previndex]["Epic Name"] then
						message = message .. "@R/@C" .. day .. " (" .. date .. ") @R- @G" .. hour .. "@R" .. apxhour
					else
						message = message .. "@R] [" .. ename .. ": @C" .. day .. " (" .. date .. ") @R- @G" .. hour .. "@R" .. apxhour
					end
				end
			elseif ltype == "leader" then
				leader = string.gsub (EpicTable[i]["Epic Leader"], "^.", string.upper)
			
				if message == message2 then
					message = message .. "@R[" .. leader .. ": @C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @R- @G" .. hour .. "@R" .. apxhour
				else
					if EpicTable[i]["Epic Leader"] == EpicTable[previndex]["Epic Leader"] then
						message = message .. "@R/@C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @R- @G" .. hour .. "@R" .. apxhour
					else
						message = message .. "@R] [" .. leader .. ": @C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @R- @G" .. hour .. "@R" .. apxhour
					end
				end
			else
				len = string.len(ltype)

				epicname = EpicTable[i]["Epic Name"]
				
				if string.find(string.sub(epicname,1,len),ltype) ~= nil then
					if message == message2 then
						message = message .. "@R[@C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @G" .. hour .. "@R" .. apxhour
					else 
						message = message .. "@R] [@C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @G" .. hour .. "@R" .. apxhour
					end
				end
			end
		end
	end
	
	SendNoEcho (channel .. " " .. message .. "@R]@w")
end -- ChannelListEpic

function TellChannel(name, line, wc)
	user = string.lower(wc[1])
	cmd = string.lower(wc[2])
	search = string.lower(wc[3])
	channel = "tell " .. user

	GetCharName()
	
	if EpicMisc["BlacklistEnabled"] == true then
		if CheckBlackList(user) == "yes" then
			reason = EpicMisc["Blacklist"][user]["Reason"]
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has been blacklisted. Reason: ", qty_colour, "", reason)

			return
		end
	end

	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		if (CheckPermission(user)) == "no" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has not been added to the permission's list")

			return
		end
	end
	
	if search ~= nil then 
		tcmd = cmd .. " " .. search
	else
		tcmd = cmd
	end
	
	if telllastcommand == tcmd then
		return
	else 
		telllastcommand = tcmd
		check (EnableTimer ("lastcmdtell", 1))
		check (ResetTimer ("lastcmdtell"))
	end
	
	ChannelBot(user, cmd, search, channel)

end -- TellChannel

function ClanChannel(name, line, wc)
	user = string.lower(wc[1])
	cmd = string.lower(wc[2])
	search = string.lower(wc[3])
	channel = "clan"

	if EpicMisc["BlacklistEnabled"] == true then
		if CheckBlackList(user) == "yes" then
			reason = EpicMisc["Blacklist"][user]["Reason"]
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has been blacklisted. Reason: ", qty_colour, "", reason)

			return
		end
	end
	
	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		if (CheckPermission(user)) == "no" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has not been added to the permission's list")

			return
		end
	end

	if search ~= nil then 
		ccmd = cmd .. " " .. search
	else
		ccmd = cmd
	end

	if clanlastcommand == ccmd then
		return
	else
		clanlastcommand = ccmd
		check (EnableTimer ("lastcmdclan", 1))
		check (ResetTimer ("lastcmdclan"))
	end

	ChannelBot(user, cmd, search, channel)
end -- ClanChannel

function ClanChannelYou(name, line, wc)
	GetCharName()
	user = charname
	cmd = string.lower(wc[1])
	search = string.lower(wc[2])
	channel = "clan"

	if search ~= nil then 
		ccmd = cmd .. " " .. search
	else
		ccmd = cmd
	end

	if clanlastcommand == ccmd then
		return
	else 
		clanlastcommand = ccmd
		check (EnableTimer ("lastcmdclan", 1))
		check (ResetTimer ("lastcmdclan"))
	end
		
	ChannelBot(user, cmd, search, channel)
end -- ClanChannelYou

function GroupChannel(name, line, wc)
	user = string.lower(wc[1])
	cmd = string.lower(wc[2])
	if wc[3] == nil then 
		search = nil
	else
		search = string.lower(wc[3])
	end
	
	channel = "gt"

	GetCharName()

	if EpicMisc["BlacklistEnabled"] == true then
		if CheckBlackList(user) == "yes" then
			reason = EpicMisc["Blacklist"][user]["Reason"]
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has been blacklisted. Reason: ", qty_colour, "", reason)

			return
		end
	end

	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		if (CheckPermission(user)) == "no" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has not been added to the permission's list")

			return
		end
	end
	
	if search ~= nil then 
		gcmd = cmd .. " " .. search
	else
		gcmd = cmd
	end
	
	if gtlastcommand == gcmd then
		return
	else 
		gtlastcommand = gcmd
		check (EnableTimer ("lastcmdgt", 1))
		check (ResetTimer ("lastcmdgt"))
	end
	
	ChannelBot(user, cmd, search, channel)
end -- GroupChannel

function FriendChannel(name, line, wc)
	user = string.lower(wc[1])
	cmd = string.lower(wc[2])
	search = string.lower(wc[3])
	channel = "ft"
	
	if EpicMisc["BlacklistEnabled"] == true then
		if CheckBlackList(user) == "yes" then
			reason = EpicMisc["Blacklist"][user]["Reason"]
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has been blacklisted. Reason: ", qty_colour, "", reason)

			return
		end
	end

	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		if (CheckPermission(user)) == "no" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has not been added to the permission's list")

			return
		end
	end
	
	if search ~= nil then 
		fcmd = cmd .. " " .. search
	else
		fcmd = cmd
	end

	if ftlastcommand == fcmd then
		return
	else 
		ftlastcommand = fcmd
		check (EnableTimer ("lastcmdft", 1))
		check (ResetTimer ("lastcmdft"))
	end
	
	ChannelBot(user, cmd, search, channel)
end -- FriendChannel

function FriendChannelYou(name, line, wc)
	GetCharName()
	user = charname
	cmd = string.lower(wc[1])
	search = string.lower(wc[2])
	channel = "ft"	

	if search ~= nil then 
		fcmd = cmd .. " " .. search
	else
		fcmd = cmd
	end

	if ftlastcommand == fcmd then
		return
	else 
		ftlastcommand = fcmd
		check (EnableTimer ("lastcmdft", 1))
		check (ResetTimer ("lastcmdft"))
	end
	
	ChannelBot(user, cmd, search, channel)
end -- FriendChannelYou

function SpouseChannel(name, line, wc)
	user = string.lower(wc[1])
	cmd = string.lower(wc[2])
	if wc[3] == nil then 
		search = nil
	else
		search = string.lower(wc[3])
	end
	
	channel = "spouse"

	GetCharName()

	if EpicMisc["BlacklistEnabled"] == true then
		if CheckBlackList(user) == "yes" then
			reason = EpicMisc["Blacklist"][user]["Reason"]
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has been blacklisted. Reason: ", qty_colour, "", reason)

			return
		end
	end

	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		if (CheckPermission(user)) == "no" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has not been added to the permission's list")

			return
		end
	end
	
	if search ~= nil then 
		gcmd = cmd .. " " .. search
	else
		gcmd = cmd
	end
	
	if spouselastcommand == gcmd then
		return
	else 
		spouselastcommand = gcmd
		check (EnableTimer ("lastcmdspouse", 1))
		check (ResetTimer ("lastcmdspouse"))
	end
	
	ChannelBot(user, cmd, search, channel)
end -- SpouseChannel

function SpouseChannelYou(name, line, wc)
	GetCharName()
	user = charname
	cmd = string.lower(wc[1])
	if wc[2] == nil then 
		search = nil
	else
		search = string.lower(wc[2])
	end
	
	channel = "spouse"

	GetCharName()

	if EpicMisc["BlacklistEnabled"] == true then
		if CheckBlackList(user) == "yes" then
			reason = EpicMisc["Blacklist"][user]["Reason"]
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has been blacklisted. Reason: ", qty_colour, "", reason)

			return
		end
	end

	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		if (CheckPermission(user)) == "no" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has not been added to the permission's list")

			return
		end
	end
	
	if search ~= nil then 
		gcmd = cmd .. " " .. search
	else
		gcmd = cmd
	end
	
	if spouselastcommand == gcmd then
		return
	else 
		spouselastcommand = gcmd
		check (EnableTimer ("lastcmdspouse", 1))
		check (ResetTimer ("lastcmdspouse"))
	end
	
	ChannelBot(user, cmd, search, channel)
end -- SpouseChannelYou

-- Channel Command Delay Functions

function LastCmdTell()
	check (EnableTimer ("lastcmdtell", 0))
	telllastcommand	= nil
end -- LastCmdTell

function LastCmdGT()
	check (EnableTimer ("lastcmdgt", 0))
	gtlastcommand = nil
end -- LastCmdGT

function LastCmdFT()
	check (EnableTimer ("lastcmdft", 0))
	ftlastcommand = nil
end -- LastCmdFT

function LastCmdClan()
	check (EnableTimer ("lastcmdclan", 0))
	clanlastcommand = nil
end -- LastCmdClan

function LastCmdSpouse()
	check (EnableTimer ("lastcmdspouse", 0))
	spouselastcommand = nil
end -- LastCmdSpouse

function HourlyNextEpicNotification()
	for i,v in pairs(EpicMisc["NotificationBot"]["Auto"]) do
		if v == true then
			Execute("ecal next epic " .. i)
		end
	end
end -- HourlyNextEpicNotification

---------------------------------------------
------------ BLACKLIST FUNCTIONS ------------
---------------------------------------------
function AddBlacklist(user, reason)	
	if CheckBlackList(user) == "yes" then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has already been added to the blacklist.")
		
		return
	end

	EpicMisc["Blacklist"][user] = {}
	EpicMisc["Blacklist"][user]["Reason"] = reason
	EpicMisc["Blacklist"][user]["Since"] = os.time()
	
	user = string.gsub (user, "^.", string.upper)

	ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has been added to the blacklist. Reason: ", qty_colour, "", reason)
	
	SaveState()
end -- AddBlacklist

function RemoveBlacklist(user)
	if CheckBlackList(user) == "no" then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " was not found on the blacklist.")
		return
	end
	
	EpicMisc["Blacklist"][user] = nil
	
	user = string.gsub (user, "^.", string.upper)
	
	ColourNote(epiccalcolour, "", "[EpicCAL] ", qty_colour, "", user, msg_colour, "", " has been removed from the blacklist.")
	
	SaveState()
end -- RemoveBlacklist

function CheckBlackList(user)
	bcheck = "no"
	
	for i,v in pairs(EpicMisc["Blacklist"]) do
		if user == i then
			bcheck = "yes"
		end
	end
	
	return bcheck
end -- CheckBlackList

function ListBlacklist()
	title = "Players on the Blacklist"
	
	local title2 = "+--------------+--------------------------------+--------------------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
		ColourNote(msg_colour, "", "| Name         | Reason                         | Time on List                               |")
		ColourNote(msg_colour, "", title2)
	end
	
	for i,v in pairs(EpicMisc["Blacklist"]) do
		username = string.gsub (i, "^.", string.upper)
		reason = EpicMisc["Blacklist"][i]["Reason"]
		
		local timenow = os.time()
		local timenow2 = EpicMisc["Blacklist"][i]["Since"]
		
		local timediff2 = {}

		timeDiff(timenow,timenow2,timediff2)

		local timeonlist = remainingtime_noteVI(timediff2)
		
		if username == nil then namespace = 12 else namespace = MakeSpace(username, 12) end
		
		if reason == nil then reasonspace = 30 else reasonspace = MakeSpace(reason, 30) end
		
		if timeonlist == nil then onlistspace = 42 else onlistspace = MakeSpace(timeonlist, 42) end

		if EpicMisc["VI"] == "NO" then
			ColourNote(msg_colour, "", "| ", user_colour, "", username .. namespace, msg_colour, "", " | ", reason_colour, "", reason .. reasonspace, msg_colour, "", " | ", remain_colour, "", onlistspace .. timeonlist,  msg_colour, "", " |")
		elseif EpicMisc["VI"] == "YES" then
			ColourNote(msg_colour, "", "User: ", user_colour, "", username .. namespace, msg_colour, "", " Reason: ", reason_colour, "", reason, msg_colour, "", " Time on Blacklist: ", remain_colour, "", timeonlist)
		end
	end

	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	end
	
	Note("")
end -- ListBlacklist

function EnableBlacklist()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Blacklist Enabled.")
	Note("")
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Any requests from players on the blacklist will be ignored.")
	Note("")
end -- EnableBlacklist

function DisableBlacklist()
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Blacklist Disabled.")
	Note("")
	ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "No requests will be ignored.")
	Note("")
	
	EpicMisc["BlacklistEnabled"] = false
	SaveState()
end	 -- DisableBlacklist

-----------------------------------------------
--------------- ALERT FUNCTIONS ---------------
-----------------------------------------------
function GetNextEpicSilent()
	if SystemTimeTable["year"] == 0 then 
		listtype = "nextsilent"
		GetSystemTime()
	else
		NextEpicSilent()
	end
end -- GetNextEpicSilent

function NextEpicSilent()
	lowestseconds = 604800 -- amount of seconds in a week 
	lowestindex = 0 -- index of epic with lowest amount of seconds

	for i, v in ipairs(EpicTable) do
		CheckLowest(i)
	end
	
	ReturnType = "table"
	alertremaining = EpicTimeDifference(lowestindex, ReturnType)
	
	AlertCheck()
end -- NextEpicSilent

function AlertCheck()
	if alertremaining == nil then
		GetNextEpicSilent()
		return
	end

	alerttime = os.time(SystemTimeTable)
	
	if alertcheck == "YES" then
		if alertremaining["day"] == 0 then
			if alertremaining["hour"] == 0 then
				if alertremaining["min"] <= 30 then			
					NextEpicComingUp()
					alertcheck = "PAUSE"
				end
			end
		end
	elseif alertcheck == "PAUSE" then
		if alertremaining["day"] == 0 then
			if alertremaining["hour"] == 0 then
				if alertremaining["min"] <= 4 then			
					alertcheck = NIL
				end
			end
		end
	else
		if alertremaining["day"] == 0 then
			if alertremaining["hour"] == 1 then
				if alertremaining["min"] == 0 then
					NextEpicComingUp()
					alertcheck = "YES"
				end
			elseif alertremaining["hour"] == 0 then
				if alertremaining["min"] <= 59 then
					if alertremaining["min"] >= 10 then
						NextEpicComingUp()
						alertcheck = "YES"
					end
				end
			else
				alertcheck = "NO"
			end
		end
	end
end -- AlertCheck

function NextEpicComingUp()
	lowestseconds = 604800 -- amount of seconds in a week 
	lowestindex = 0 -- index of epic with lowest amount of seconds

	for i, v in ipairs(EpicTable) do
		CheckLowest(i)
	end

	ReturnType = "VI"
	timeremaining = EpicTimeDifference(lowestindex, ReturnType)
	
	if EpicTable[lowestindex]["Epic Name"] == "icefall1" then
		ename = "Icefall 1"
	elseif EpicTable[lowestindex]["Epic Name"] == "icefall2" then
		ename = "Icefall 2"
	elseif EpicTable[lowestindex]["Epic Name"] == "oc" then
		ename = "OC"
	else 
		if EpicTable[lowestindex]["Epic Name"] ~= nil then
			ename = string.gsub (EpicTable[lowestindex]["Epic Name"], "^.", string.upper)
		end
	end
	
	if ename ~= nil then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "NEXT EPIC ALERT ", "red", "" , "[" .. ename .. " Epic]", msg_colour, "" , " starting in ", qty_colour, "", trim(timeremaining))
		Note("")
	end
end -- NextEpicComingUp

-----------------------------------------------
-------------- UTILITY FUNCTIONS --------------
-----------------------------------------------
function SetServerTime(sertime)
	timeline = string.lower(sertime)
	SystemTimeTable = {}
	SystemTimeTable["isdst"] = false

	for time in timeline:gmatch("%d%d:%d%d:%d%d") do		
		hour = time:gsub(":%d+:%d+", "------")
	
		for shour in hour:gmatch("%d+") do
			SystemTimeTable["hour"] = tonumber(shour)
		end
		
		for min in time:gmatch(":%d%d:") do
			for smin in min:gmatch("%d+") do
				SystemTimeTable["min"] = tonumber(smin)
			end
		end

		sec = time:gsub("%d+:%d+:", "------")

		for ssec in sec:gmatch("%d+") do
			SystemTimeTable["sec"] = tonumber(ssec)
		end		
	end
	
	for day in timeline:gmatch("%-%s%a+") do
		for sday in day:gmatch("%a+") do
			for i,v in ipairs (DaysofWeek) do
				if v == sday then
					SystemTimeTable["wday"] = i
				end
			end
		end		
	end
	
	for date in timeline:gmatch("%d+%s%a+,%s%d+") do
		for year in date:gmatch(",%s%d+") do
			for syear in year:gmatch("%d+") do
				SystemTimeTable["year"] = tonumber(syear)
			end
		end
		
		for month in date:gmatch("%a+") do
			for i,v in ipairs (Months) do 
				if v == month then
					SystemTimeTable["month"] = i
				end
			end
		end
		
		for day in date:gmatch("%d+%s") do
			for sday in day:gmatch("%d+") do	
				SystemTimeTable["day"] = tonumber(sday)
			end
		end
	end
	
	MonthIndex = SystemTimeTable["month"]
	yday = MonthsYDay[MonthIndex] + SystemTimeTable["day"]
	
	if (SystemTimeTable["year"]%4) == 0 then yday = yday + 1 end
	
	SystemTimeTable["yday"] = yday
	
	listdayvar = DaysofWeek[SystemTimeTable["wday"]]

	numdaytomrrow = SystemTimeTable["wday"] + 1

	if numdaytomrrow == 8 then numdaytomrrow = 1 end
	
	listdayvartomorrow = DaysofWeek[numdaytomrrow]
end -- SetServerTime

function GetSystemTime()
	world.EnableGroup("SystemTime", 1)
	SendNoEcho ("real time")
end -- GetSystemTime

function GetSystemTimeTrig(name, line, wc)
	mday = tonumber(wc[5])
	year = tonumber(wc[7])

	day = string.lower(wc[4])
	
	listdayvar = day
	
	month = string.lower(wc[6])
	
	for i,v in ipairs(DaysofWeek) do
		if DaysofWeek[i] == day then
			wday = i
			wdaytom = i + 1
			
			if wdaytom == 8 then wdaytom = 1 end
			
			listdayvartomorrow = DaysofWeek[wdaytom]
		end
	end

	for i,v in ipairs(Months) do
		if Months[i] == month then
			wmon = i
		end
	end
	
	for j,u in ipairs(MonthsYDay) do
		if j == wmon then
			yday = MonthsYDay[j]
		end
	end

	yday = yday + mday	
	
	if (year%4) == 0 then yday = yday + 1 end
	
    SystemTimeTable = {
      month = wmon,
      wday = wday,
      yday = yday,
      day = mday,
      min = tonumber(wc[2]),
      sec = tonumber(wc[3]),
      hour = tonumber(wc[1]),
      year = year,
	  isdst = false,
      }
	
	OSSystemTimeTable = os.date("*t")
	OSSystemTime = os.time()

	if behindcheck == nil then 
		behindcheck = "NO"

		timenow2 = os.time(SystemTimeTable)
		timenow = OSSystemTime

		timediff2 = {}

		if timenow < timenow2 then 
			timeDiff(timenow2,timenow,timediff2)
			behindcheck = "YES"
		elseif timenow >= timenow2 then
			timeDiff(timenow,timenow2,timediff2)
		end

		timezonedifference = {}
		
		for i,v in pairs(timediff2) do
			timezonedifference[i] = v
		end
	end

	world.EnableGroup("SystemTime", 0)
	
	if listtype == "next" then  
		NextEpic()
	elseif listtype == "nextsilent" then
		NextEpicSilent()
	elseif listtype == "none" then
	elseif listtype == "permissions" then
		ListPermissions()
	elseif listtype == "post" then
		StartNotePost()
	else
		ListEpic()
	end	
end -- GetSystemTimeTrig

function EpicTimeDifference(TableIndex, ReturnType)	
	if TableIndex == nil then
		return
	end
	
	OSSystemTimeTable2 = os.date("*t")
	OSSystemTime2 = os.time()

	tdef = OSSystemTime2 - OSSystemTime
	
	timenow = os.time(SystemTimeTable)
	
	timenow = timenow + tdef

	timenow2 = os.time(EpicTable[TableIndex]["Time Table"])
	
	if timenow > timenow2 then
		--- insert over message stuff here
	else
		timediff2 = {}
		timeDiff(timenow2,timenow,timediff2)

		if ReturnType == "normal" then
			local rtime = remainingtime_note(timediff2)
			return rtime
		elseif ReturnType == "VI" then
			local rtime = remainingtime_noteVI(timediff2)
			return rtime
		elseif ReturnType == "table" then
			return timediff2
		end
	end	
end -- EpicTimeDifference

-- FUNCTION TO CALCULATION DIFFERENCE BETWEEN TWO TIMES --
function timeDiff(t2,t1,script)
    local d1,d2,carry,diff = os.date('*t',t1),os.date('*t',t2),false,{}

	tprint(diff)
    local colMax = {60,60,24,os.date('*t',os.time{year=d1.year,month=d1.month+1,day=0}).day,12}
    d2.hour = d2.hour - (d2.isdst and 1 or 0) + (d1.isdst and 1 or 0) -- handle dst
    for i,v in ipairs({'sec','min','hour','day','month','year'}) do
        diff[v] = d2[v] - d1[v] + (carry and -1 or 0)
        carry = diff[v] < 0
        if carry then diff[v] = diff[v] + colMax[i] end
    end
    for i,v in pairs(diff) do
        script[i] = v
    end
    return diff
end -- timeDiff

function MakeSpace(title, maxleng)
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(maxleng)
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
	end

	spacing = string.rep(" ", lendif)
	return spacing
end -- MakeSpace

function HelpSpacing(title, title2)
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
		lendif = lendif * 0.5
	end

	spacing = string.rep(" ", lendif)
	
	return spacing
end -- HelpSpacing

function remainingtime_noteVI(time)
	remaining_time = ""

	if time["year"] ~= nil then
		if tonumber(time["year"]) == 1 then
			remaining_time = time["year"] .. " year  "
		elseif tonumber(time["year"]) ~= 0 then
			remaining_time = time["year"] .. " years "
		end
	end

	ttype = "month"
	remaining_time = GetTimeMessageVI(time, ttype, remaining_time)
	
	ttype = "day"
	remaining_time = GetTimeMessageVI(time, ttype, remaining_time)
	
	ttype = "hour"
	remaining_time = GetTimeMessageVI(time, ttype, remaining_time)
	
	ttype = "min"
	remaining_time = GetTimeMessageVI(time, ttype, remaining_time)
	
	ttype = "sec"
	remaining_time = GetTimeMessageVI(time, ttype, remaining_time)
	
    return(remaining_time)
end -- remainingtime_note

function remainingtime_note(time)
	remaining_time = ""

	if time["year"] ~= nil then
		if tonumber(time["year"]) == 1 then
			remaining_time = time["year"] .. " year  "
		elseif tonumber(time["year"]) ~= 0 then
			remaining_time = time["year"] .. " years "
		end
	end

	ttype = "month"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
	ttype = "day"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
	ttype = "hour"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
	ttype = "min"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)

	ttype = "sec"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
    return(remaining_time)
end -- remainingtime_noteVI

function GetTimeMessageVI(time, ttype, remaining_time)
	if remaining_time == nil then
		remaining_time = ""
	end

	if time[ttype] ~= nil then
		if tonumber(time[ttype]) == 0 then
		elseif tonumber(time[ttype]) == 1 then
			remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. " "
		-- elseif tonumber(time[ttype]) < 10 then
			-- remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. "s "
		else 
			remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. "s "
		end
	end
	
	return (remaining_time)
end -- GetTimeMessage

function GetTimeMessage(time, ttype, remaining_time)
	if remaining_time == nil then
		remaining_time = ""
	end

	if ttype == "hour" then
		if remaining_time == "" then
			remaining_time = "       "
		end
	end
	
	if time[ttype] ~= nil then
		if tonumber(time[ttype]) == 0 then
			if ttype == "min" then
				remaining_time = remaining_time .. "        "
			elseif ttype == "hour" then
				remaining_time = remaining_time .. "         "
			end
		elseif tonumber(time[ttype]) == 1 then
			if ttype ~= "sec" then
				if remaining_time == "" then
					remaining_time = time[ttype] .. " " .. ttype .. "  "
				else
					remaining_time = remaining_time .. " " .. time[ttype] .. " " .. ttype .. "  "
				end
			else
				if remaining_time == "" then
					remaining_time = time[ttype] .. ttype .. "  "
				else
					remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. "  "
				end
			end
		elseif tonumber(time[ttype]) < 10 then
			if ttype ~= "sec" then
				if remaining_time == "" then
					remaining_time = time[ttype] .. " " .. ttype .. "s "
				else
					remaining_time = remaining_time .. " " .. time[ttype] .. " " .. ttype .. "s "
				end
			else
				if remaining_time == "" then
					remaining_time = time[ttype] .. ttype .. "s "
				else
					remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. "s "
				end
			end
		else 
			remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. "s "
		end
	end
	
	return (remaining_time)
end -- GetTimeMessage

function TimeToSeconds(tablename)
	local seconds = 0

	if tablename["year"] >= 0 then
		seconds = (tablename["year"] * 31536000)
	end

	if tablename["month"] >= 0 then
		seconds = (tablename["month"] * 2592000) + seconds
	end

	if tablename["day"] >= 0 then
		seconds = (tablename["day"] * 86400) + seconds
	end
		
	if tablename["hour"] >= 0 then
		seconds = (tablename["hour"] * 3600) + seconds
	end

	if tablename["min"] >= 0 then
		seconds = (tablename["min"] * 60) + seconds
	end

	if tablename["sec"] >= 0 then	
		seconds = tablename["sec"] + seconds
	end

    return(seconds)
end -- TimeToSeconds

function TimeToNormal(time)
	local years = 0
	local months = 0
	local days = 0
	local hours = 0
	local days = 0
	local mins = 0
	local days = 0
	local secs = 0
	local message = ""
	
	if time > 31535999 then
		years = math.floor(time / 31536000)
		
		time = time - (years * 31536000)
	end

	if time > 2591999 then
		months = math.floor(time / 2592000)
		
		time = time - (months * 2592000)
	end
	
	if time > 86399 then
		days = math.floor(time / 86400)
		
		time = time - (days * 86400)
	end

	if time > 3599 then
		hours = math.floor(time / 3600)
		
		time = time - (hours * 3600)
	end

	if time > 59 then
		mins = math.floor(time / 60)
		
		time = time - (mins * 60)
	end
	
	if time < 59 then
		secs = time
	end
	
	if years ~= 0 then
		if years == 1 then
			message = "@R" .. years .. " @Dyear@w "
		elseif years ~= 0 then
			message = "@R" .. years .. " @Dyears@w "
		end
	end

	if months ~= 0 then
		if months == 1 then
			message = message .. "@R" .. months .. " @Dmonth@w "
		elseif months ~= 0 then
			message = message .. "@R" .. months .. " @Dmonths@w "
		end
	end
		
	if days ~= 0 then
		if days == 1 then
			message = message .. "@R" .. days .. " @Dday@w "
		elseif days ~= 0 then
			message = message .. "@R" .. days .. " @Ddays@w "
		end
	end
	
	if hours ~= 0 then
		if hours == 1 then
			message = message .. "@R" .. hours .. " @Dhour@w "
		elseif hours ~= 0 then
			message = message .. "@R" .. hours .. " @Dhours@w "
		end
	end

	if mins ~= 0 then
		if mins == 1 then
			message = message .. "@R" .. mins .. " @Dmin@w "
		elseif mins ~= 0 then
			message = message .. "@R" .. mins .. " @Dmins@w "
		end
	end

	if secs ~= 0 then
		if secs == 1 then
			message = message .. "@R" .. secs .. " @Dsec@w"
		elseif secs ~= 0 then
			message = message .. "@R" .. secs .. " @Dsecs@w"
		end
	end
	
	return (message)
end -- TimeToNormal

function SeperateDate(dateonly)	
	EpicTable[TableIndex]["Time Table"] = {}
	
	for date in dateonly:gmatch("%a%a%a") do
		for i,v in ipairs (Months) do
			if Months[i] == date then
				EpicTable[TableIndex]["Time Table"]["month"] = i
			end
		end
	end
	
	for date in dateonly:gmatch("%d%d") do
		EpicTable[TableIndex]["Time Table"]["day"] = tonumber(date)
	end
end -- SeperateDate

function SeperateTime(timeonly)
	len = string.len(timeonly)
	
	if len == 3 or len == 4 then
	
		for hour in timeonly:gmatch("%d+") do
			EpicTable[TableIndex]["Hour"] = tonumber(hour)
		end
		
		EpicTable[TableIndex]["Minute"] = 0
	elseif len == 5 or len == 6 then
		st1 = timeonly:gsub("%d%d[ap]m", "----")

		for hour in st1:gmatch("%d+") do EpicTable[TableIndex]["Hour"] = tonumber(hour) end

		for min in timeonly:gmatch("%d%d[ap]m") do
			st2 = min:gsub("[ap]m", "--")
			for st3 in st2:gmatch("%d+") do EpicTable[TableIndex]["Minute"] = tonumber(st3) end
		end	
	end
end -- SeperateTime

function NoteRoom(cmd)
	if cmd == "add" then
		AddRoom()
	elseif cmd == "remove" then
		RemoveRoom()
	end
end -- NoteRoom

function AddRoom()
	GetRoom()
	
	if EpicMisc["NoteRooms"][gmcproomid] == nil then
		EpicMisc["NoteRooms"][gmcproomid] = {}
		EpicMisc["NoteRooms"][gmcproomid]["Name"] = strip_colours(gmcpname)
		EpicMisc["NoteRooms"][gmcproomid]["Area"] = strip_colours(gmcparea)
		
		if EpicMisc["VI"] == "NO" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", help_command_colour, "", "[" .. strip_colours(gmcparea), msg_colour, "", "/", help_command_colour, "", strip_colours(gmcpname), msg_colour, "", "/", help_command_colour, "", gmcproomid .. "]", msg_colour, "", " has been added to the database")
			Note("")
		elseif EpicMisc["VI"] == "YES" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", help_command_colour, "", strip_colours(gmcparea), msg_colour, "", " ", help_command_colour, "", strip_colours(gmcpname), msg_colour, "", " ", help_command_colour, "", gmcproomid, msg_colour, "", " has been added to the database")
			Note("")
		end
		
		SaveState()
	else
		if EpicMisc["VI"] == "NO" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", help_command_colour, "", "[" .. strip_colours(gmcparea), msg_colour, "", "/", help_command_colour, "", strip_colours(gmcpname), msg_colour, "", "/", help_command_colour, "", gmcproomid .. "]", msg_colour, "", " has already been added to the database")
			Note("")
		elseif EpicMisc["VI"] == "YES" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", help_command_colour, "", strip_colours(gmcparea), msg_colour, "", " ", help_command_colour, "", strip_colours(gmcpname), msg_colour, "", " ", help_command_colour, "", gmcproomid, msg_colour, "", " has already been added to the database")
			Note("")
		end
	end
end -- AddRemove

function RemoveRoom()
	GetRoom()
	
	if EpicMisc["NoteRooms"][gmcproomid] ~= nil then
		EpicMisc["NoteRooms"][gmcproomid] = nil
		
		if EpicMisc["VI"] == "NO" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", help_command_colour, "", "[" .. strip_colours(gmcparea), msg_colour, "", "/", help_command_colour, "", strip_colours(gmcpname), msg_colour, "", "/", help_command_colour, "", gmcproomid .. "]", msg_colour, "", " has been removed from the database")
			Note("")
		elseif EpicMisc["VI"] == "YES" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", help_command_colour, "", strip_colours(gmcparea), msg_colour, "", " ", help_command_colour, "", strip_colours(gmcpname), msg_colour, "", " ", help_command_colour, "", gmcproomid, msg_colour, "", " has been removed from the database")
			Note("")
		end
		
		SaveState()
	else
		if EpicMisc["VI"] == "NO" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", help_command_colour, "", "[" .. strip_colours(gmcparea), msg_colour, "", "/", help_command_colour, "", strip_colours(gmcpname), msg_colour, "", "/", help_command_colour, "", gmcproomid .. "]", msg_colour, "", " is not in the database")
			Note("")
		elseif EpicMisc["VI"] == "YES" then
			ColourNote(epiccalcolour, "", "[EpicCAL] ", help_command_colour, "", strip_colours(gmcparea), msg_colour, "", " ", help_command_colour, "", strip_colours(gmcpname), msg_colour, "", " ", help_command_colour, "", gmcproomid, msg_colour, "", " is not in the database")
			Note("")
		end
	end
end -- RemoveRoom

function GetRoom()
	Send_GMCP_Packet("request room")

	gmcparea = gmcp("room.info.zone")
	gmcproomid = tonumber(gmcp("room.info.num"))
	gmcpname = gmcp("room.info.name")
end -- GetRoom

function ListRooms()
	title = "Note Posting Safe Room List"

	local title2 = "+-------+------------------------------------------+-------------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)

	if EpicMisc["VI"] == "NO" then
		Note("")
		ColourNote(msg_colour, "", title2)	
		ColourNote(msg_colour, "", "| Room# | Room Name                                | Area name                           |")
		ColourNote(msg_colour, "", title2)
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end
	
	for i,v in pairs(EpicMisc["NoteRooms"]) do

		roomnum = i
		roomname = EpicMisc["NoteRooms"][i]["Name"]
		areaname =  nil

		for j,k in pairs(AreaNames) do 
			if EpicMisc["NoteRooms"][i]["Area"] == j then
				areaname = k
			end
		end
		
		if areaname == nil then areaname = EpicMisc["NoteRooms"][i]["Area"] end

		if roomname == nil then rnamespace = 40 else rnamespace = MakeSpace(roomname, 40) end
	
		if areaname == nil then areaspace = 35 else areaspace = MakeSpace(areaname, 35) end

		if EpicMisc["VI"] == "NO" then
			ColourNote(msg_colour, "", "| ", epic_colour, "", roomnum, msg_colour, "", " | ", leader_colour, "", roomname .. rnamespace, msg_colour, "", " | ", remain_colour, "", areaname .. areaspace, msg_colour, "", " |")
		elseif EpicMisc["VI"] == "YES" then
			ColourNote(msg_colour, "", "Room Number: ", epic_colour, "", roomnum, msg_colour, "", " Room Name: ", leader_colour, "", roomname .. rnamespace, msg_colour, "", " Area Name: ", remain_colour, "", areaname)
		end	
	end
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(msg_colour, "", title2)
	end
	
	Note("")
end -- ListRooms

function GetCharName()
	gmcpbase = gmcp("char.base") -- fetch char.status and return it as a Lua table
	charname = string.lower(gmcpbase.name)
end -- GetCharName

function EpicHour(ehindex)
	if EpicTable[ehindex]["Time Table"]["min"] > 9 then
		hour = EpicTable[ehindex]["Hour"] .. ":" .. EpicTable[ehindex]["Time Table"]["min"] .. " " ..  string.upper(EpicTable[ehindex]["AMPM"])			
	elseif EpicTable[ehindex]["Time Table"]["min"] ~= 0 then
		hour = EpicTable[ehindex]["Hour"] .. ":0" .. EpicTable[ehindex]["Time Table"]["min"] .. " " ..  string.upper(EpicTable[ehindex]["AMPM"])
	else
		hour = EpicTable[ehindex]["Hour"] .. ":00 " .. string.upper(EpicTable[ehindex]["AMPM"])
	end

	return hour
end -- EpicHour

function TimeZoneEpicHour(tzindex)
	ampm = string.upper(EpicTable[tzindex]["AMPM"])
	hour1 = EpicTable[tzindex]["Hour"]
	min1 = EpicTable[tzindex]["Time Table"]["min"]
	hour2 = timezonedifference["hour"]
	min2 = timezonedifference["min"]

	if min2 == 29 or min2 == 31 then
		min2 = 30
	end
	
	if min2 == 59 then
		min2 = 0
		hour2 = hour2 + 1
	end
	
	hour3 = 0
	min3 = 0
	
	tzdayindex = EpicTable[tzindex]["Time Table"]["wday"]
	
	if behindcheck == "NO" then
		hour3 = hour1 + hour2
		min3 = min1 + min2
		
		if min3 >= 60 then 
			hour3 = hour3 + 1
			min3 = min3 - 60		
		end
		
		if ampm == "AM" then
			if hour3 > 24 then
				hour3 = hour3 - 24
				tzdayindex = tzdayindex + 1
			elseif hour3 > 12 then
				hour3 = hour3 - 12
				ampm = "PM"
			elseif hour3 == 12 then
				ampm = "PM"
			end
		elseif ampm == "PM" then
			if hour3 > 24 then
				hour3 = hour3 - 24
				tzdayindex = tzdayindex + 1
				ampm = "AM"
			elseif hour3 > 12 then
				if hour1 == 12 then
					hour3 = hour3 - 12
					ampm = "PM"
				else
					hour3 = hour3 - 12
					ampm = "AM"
					tzdayindex = tzdayindex + 1
				end
			elseif hour3 == 12 then
				ampm = "PM"
			end
		end
	elseif behindcheck == "YES" then
		hour3 = hour1 - hour2
		min3 = min1 - min2
		
		if min3 < 0 then 
			hour3 = hour3 - 1
			min3 = min3 + 60		
		end
		
		if ampm == "AM" then
			if hour3 < 0 then
				hour3 = hour3 + 12
				ampm = "PM"
				tzdayindex = tzdayindex - 1
			elseif hour3 == 0 then
				hour3 = 12
				ampm = "AM"
			end
		elseif ampm == "PM" then
			if hour3 < 0 then
				hour3 = hour3 + 12
				ampm = "AM"
			elseif hour3 == 0 then
				hour3 = 12
				ampm = "PM"
			elseif hour1 == 12 then
				if hour3 < 12 then 
					ampm = "AM"
				end
			end
		end
	end

	if min3 > 9 then
		hour = hour3 .. ":" .. min3 .. " " ..  ampm
	elseif min3 ~= 0 then
		hour = hour3 .. ":0" .. min3 .. " " ..  ampm
	else
		hour = hour3 .. ":00 " .. ampm
	end
	
	return hour, tzdayindex
end -- TimeZoneEpicHour

---------------------------------------------
--------------- HELP FUNCTION ---------------
---------------------------------------------
function EpicCalendarHelp()	
	local title = "Tallimos' Epic Calendar v" .. PLUGIN_VERSION .. " Help"
	local title2 = noteline
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end
	
	ColourNote(help_colour, "", "This plugin gives the user an easy way of keeping track of upcoming epic runs as well as some")
	ColourNote(help_colour, "", "nice few extras. Once installed the user can use the commands below to update the list. Also")
	ColourNote(help_colour, "", "if a note is posted while the user is online the list will automatically get updated.")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end

	Note("")
	
	ColourNote(help_colour, "", "Main Commands")
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", "-------------")
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end
	
	ColourNote(help_command_colour, "", "ecal update  ", help_colour, "", " - checks and see if the latest version of the plugin is installed")

	ColourNote(help_command_colour, "", "ecal reset   ", help_colour, "", " - clears the epic run list and adds all upcoming runs")

	ColourNote(help_command_colour, "", "ecal list    ", help_colour, "", " - lists all upcoming epic runs")

	ColourNote(help_command_colour, "", "ecal vi      ", help_colour, "", " - enables/disables the vi friendly option")
	
	ColourNote(help_command_colour, "", "ecal tdif    ", help_colour, "", " - toggles hour display between mudtime and user's timezone")
	ColourNote(help_colour, "", "                this only affects displays sent to USER ONLY anything sent via channel or note will")
	ColourNote(help_colour, "", "                show mud time as the hour")
	ColourNote(help_command_colour, "", "ecal search <epic>   ", help_colour, "", " - searches the epic runs list")
	
	ColourNote(help_command_colour, "", "ecal nupdate <note #>", help_colour, "", " - used when epic leader posts a subject line to long")
	
	ColourNote(help_command_colour, "", "ecal checkversion    ", help_colour, "", " - checks to see if there is a newer version of the plugin available")
	
	ColourNote(help_command_colour, "", "ecal changelog       ", help_colour, "", " - displays the changelog for the plugin")
	
	Note("")

	ColourNote(help_colour, "", "Other Features")
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", "--------------")
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end
	
	ColourNote(help_command_colour, "", "ecal help bot ", help_colour, "", " - for more information on a notification and channel command bot")

	ColourNote(help_command_colour, "", "ecal help next", help_colour, "", " - for more information on some useful commands to display the next upcoming epic")
	
	ColourNote(help_command_colour, "", "ecal help rt  ", help_colour, "", " - for more information on some useful commands to display the next upcoming epic")

	Note("")
	
	ColourNote(help_command_colour, "", "PLEASE NOTE", help_colour, "", ": the user can also use ", help_command_colour, "", "epiccalendar", help_colour, "", " instead of ", help_command_colour, "", "ecal")
	
	Note("")
	
	ColourNote(help_colour, "", "User's Guide")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", "------------")
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end
	
	Hyperlink ("https://docs.google.com/document/d/1Ewa9IlA4ZTMRowXQzK1mX-CHGw3Fjys7PhgpWLRRra4/edit?usp=sharing", "https://docs.google.com/document/d/1Ewa9IlA4ZTMRowXQzK1mX-CHGw3Fjys7PhgpWLRRra4/edit?usp=sharing", "Tallimos' Epic Calendar User's Guide", help_command_colour, "", 1)
	
	Note("")
	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end
	
	Note("")
end	-- EpicCalendarHelp

function EpicCalendarHelpBot()	
	local title = "Tallimos' Epic Calendar Help - Notification Bot"
	local title2 = noteline
	
	spacing = HelpSpacing(title, title2)	
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", "Tallimos' Epic Calendar Help - Notification Bot")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end

	ColourNote(help_colour, "", "The notification bot allows the user to alert themselves of upcoming epic runs. If an epic is")
	ColourNote(help_colour, "", "going to start within 1 hour or less the system will remind the user about the upcoming epic")
	ColourNote(help_colour, "", "run.")
	Note("")
	ColourNote(help_colour, "", "Also with this system the user can grant whoever they want access to " , qty_colour, "", "next", help_colour, "", " commands without")
	ColourNote(help_colour, "", "having to install the plugin themselves. See ", help_command_colour, "", "ecal help next", help_colour, "", " for more information on those")
	ColourNote(help_colour, "", "commands.")
	Note("")
	ColourNote(help_colour, "", "Finally this system will also allow users to post hourly reminders to channels of their")
	ColourNote(help_colour, "", "choosing of the next up coming epic run.")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end

	ColourNote(help_command_colour, "", "ecal bot <enable|disable>    ", help_colour, "", " - enables/disables the main bot system")
	ColourNote(help_command_colour, "", "ecal bot <auto|commands> list", help_colour, ""," - lists the channels and their settings for the specified system")

	ColourNote(help_command_colour, "", "ecal bot <auto|commands|alert> <enable|disable>  ", help_colour, "", " - enables/disables the specified system")

	ColourNote(help_command_colour, "", "ecal bot <auto|commands> <enable|disable> <channel>", help_colour, "", " - enables/disables the channel notification")
	ColourNote(help_colour, "", "                                                      in the specified system")

	ColourNote(help_command_colour, "", "ecal bot <add|remove> room", help_colour, "", " - adds/removes the current room to the approved note sending")
	ColourNote(help_colour, "", "                             room list")

	ColourNote(help_command_colour, "", "ecal bot list room        ", help_colour, "", " - displays the list of approved note sending rooms")
	
	ColourNote(help_command_colour, "", "ecal bot status           ", help_colour, "", " - displays the status of the notification bot and its features")

	Note("")

	ColourNote(help_colour, "", "Power User Commands")
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", "-------------------")
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end


	ColourNote(help_command_colour, "", "ecal bot <add|remove> <player> ", help_colour, "", " - add/removes players to the channel command permission system")

	ColourNote(help_command_colour, "", "ecal bot plist                 ", help_colour, "", " - list all players who have access to the channel commands")

	ColourNote(help_command_colour, "", "ecal bot permissions           ", help_colour, "", " - toggles channel command access between ", qty_colour, "", "LIST", help_colour, "", " and ", qty_colour, "", "ALL", help_colour, "", ". default is")
	ColourNote(help_colour, "", "                                  set to ", qty_colour, "", "LIST")

	ColourNote(help_colour, "", "Blacklist Commands")
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", "------------------")
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end

	ColourNote(help_command_colour, "", "ecal bot bl <enable|disable>     ", help_colour, "", " - enables/disables blacklist for channel command access")
	
	ColourNote(help_command_colour, "", "ecal bot bl                      ", help_colour, "", " - displays who is on the blacklist")
	
	ColourNote(help_command_colour, "", "ecal bot bl add <player> <reason>", help_colour, "", " - adds a player to the blacklist with the option to add the")
	ColourNote(help_colour, "", "                                    reason why")
	
	ColourNote(help_command_colour, "", "ecal bot bl remove <player>      ", help_colour, "", " - remove a player from the blacklist")
	Note("")
	
	ColourNote(help_command_colour, "", "PLEASE NOTE", help_colour, "", ": only ", qty_colour, "", "ft", help_colour, "", ", ", qty_colour, "", "gt", help_colour, "", ", ", qty_colour, "", "clan", help_colour, "", " and ", qty_colour, "", "tells", help_colour, "", " have been added to the channel command system")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end

	Note("")
end	-- EpicCalendarHelpBot

function EpicCalendarHelpNext()	
	local title = "Tallimos' Epic Calendar Help - Next Commands"
	local title2 = noteline
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", "Tallimos' Epic Calendar Help - Next Commands")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end
	
	ColourNote(help_colour, "", "The next commands are basically just that, it will show the next epic coming up in various")
	ColourNote(help_colour, "", "categories.")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end

	ColourNote(help_command_colour, "", "ecal nextepic            ", help_colour, "", " - displays to the user which epic run is coming up next")

	ColourNote(help_command_colour, "", "ecal nextepic <epic>     ", help_colour, "", " - displays when the next specified epic run is coming up")

	ColourNote(help_command_colour, "", "ecal nextday <day>       ", help_colour, "", " - displays the first epic run on a particular day")

	ColourNote(help_command_colour, "", "ecal nextleader <leader> ", help_colour, "", " - displays the next epic run coming up for a particular leader")
	Note("")
	
	ColourNote(help_colour, "", "If the user specifies a channel in the above commands then the message will get displayed to")
	ColourNote(help_colour, "", "that channel. For example '", help_command_colour, "", "ecal nextepic inferno ft", help_colour, "", "' will display the next schedule inferno")
	ColourNote(help_colour, "", "epic run to friend talk. ", help_command_colour, "", "Take Note", help_colour, "", " - to display the next upcoming epic to a channel the user")
	ColourNote(help_colour, "", "must use ", help_command_colour, "", "ecal nextepic epic <channel>")
	Note("")
	
	ColourNote(help_colour, "", "Channel Command System")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", "----------------------")
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end
	
	ColourNote(help_colour, "", "If the channel command system has been activated the users who have access can using the")
	ColourNote(help_colour, "", "commands below to see upcoming epic runs")
	Note("")
	
	ColourNote(help_command_colour, "", "!nextepic            ", help_colour, "", " - displays the next upcoming epic")

	ColourNote(help_command_colour, "", "!nextepic <epic>     ", help_colour, "", " - displays when the next specified epic is scheduled")
	
	ColourNote(help_command_colour, "", "!nextleader <leader> ", help_colour, "", " - displays the first epic scheduled for that particular leader")

	ColourNote(help_command_colour, "", "!nextday <day>       ", help_colour, "", " - displays the first epic of the day on that particular day")
	
	ColourNote(help_command_colour, "", "!listday             ", help_colour, "", " - displays the epic schedule for the current day on one line")

	ColourNote(help_command_colour, "", "!listday <day>       ", help_colour, "", " - displays the epic schedule for a particular day on one line")

	ColourNote(help_command_colour, "", "!listepic            ", help_colour, "", " - displays the entire epic schedule on one line, sorted by day")

	ColourNote(help_command_colour, "", "!listepic leader     ", help_colour, "", " - displays the entire epic schedule on one line, grouped by leader")

	ColourNote(help_command_colour, "", "!listepic epic       ", help_colour, "", " - displays the entire epic schedule on one line, sorted by epic name")

	ColourNote(help_command_colour, "", "!listepic <epic name>", help_colour, "", " - displays the full schedule of the epic the user searched for")

	ColourNote(help_command_colour, "", "!listleader <leader> ", help_colour, "", " - displays the full schedule for a particular leader")

	ColourNote(help_command_colour, "", "!listepic note       ", help_colour, "", " - will request the bot to send them the schedule via a note")

	ColourNote(help_command_colour, "", "!noteremove <notenum>", help_colour, "", " - will request the bot to remove the schedule note")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end

	Note("")
end	-- EpicCalendarHelpNext

function EpicCalendarHelpRT()
	local title = "Tallimos' Epic Calendar Help - Approximate Run Time"
	local title2 = noteline
	
	spacing = HelpSpacing(title, title2)	
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", "Tallimos' Epic Calendar Help - Approximate Run Time")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end

	ColourNote(help_colour, "", "The epic calendar comes with a customizable Approximate Run Time calculator. When epic leaders")
	ColourNote(help_colour, "", "post multiple epics in one note earlier versions of the calendar would set them with the same")
	ColourNote(help_colour, "", "start time. Since v1.9 approximate start times will now be given instead.")
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end
	
	Note("")

	ColourNote(help_colour, "", "Customizable Commands")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", "---------------------")
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end

	ColourNote(help_command_colour, "", "ecal rt list                 ", help_colour, "", " - lists current stored approximate run times")

	ColourNote(help_command_colour, "", "ecal rt gt                   ", help_colour, "", " - displays time allocated for grouping time")
	
	ColourNote(help_command_colour, "", "ecal rt gt <enable|disable>  ", help_colour, "", " - adds/removes grouping time from approximate start time equation")
	
	ColourNote(help_command_colour, "", "ecal rt gt <minutes>         ", help_colour, "", " - changes time allocated for grouping time")
	
	ColourNote(help_command_colour, "", "ecal rt edit <epic> <minutes>", help_colour, "", " - changes the approximate run time for <epic>")

	Note("")
	
	ColourNote(help_command_colour, "", "PLEASE NOTE", help_colour, "", " the user may also use ", help_command_colour, "", "ecal runtime", help_colour, "", " as well")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end

	Note("")
end	-- EpicCalendarHelpRT

function EpicCalendarHelpCredits()
	local title = "Tallimos' Epic Calendar Help - Credits"
	local title2 = noteline
	
	spacing = HelpSpacing(title, title2)	
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", "Tallimos' Epic Calendar Help - Credits")

	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	elseif EpicMisc["VI"] == "YES" then
		Note("")
	end

	ColourNote(help_colour, "", "Without the help from the people listed below Tallimos' Epic Calendar would not exist. So I")
	ColourNote(help_colour, "", "would like to thank each and every one of them no matter how big or small of a contribute they")
	ColourNote(help_colour, "", "had.")
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end
	
	Note("")

	IndexedHelpersTable = {}

	for k, v in pairs(Helpers) do
		table.insert(IndexedHelpersTable, {["Name"]=k, ["Contribution"]=v})
	end
	
	table.sort(IndexedHelpersTable, function (a, b) return a["Name"] < b["Name"] end)

	for i,v in ipairs(IndexedHelpersTable) do
		name = IndexedHelpersTable[i]["Name"]
		contribution = IndexedHelpersTable[i]["Contribution"]
	
		if name == nil then namespace = 9 else namespace = MakeSpace(name, 9) end
	
		ColourNote(help_command_colour, "", name .. namespace, help_colour, "", " - " .. contribution)
	end
	
	if EpicMisc["VI"] == "NO" then
		ColourNote(help_colour, "", noteline)
	end

	Note("")
end	-- EpicCalendarHelpCredits

function GetSavedData()
	if GetVariable ("ecpastfirstinstall") == "true" then
		assert (loadstring (GetVariable ("EpicTable") or "")) ()
		assert (loadstring (GetVariable ("EpicPermissionTable") or "")) ()
		assert (loadstring (GetVariable ("EpicMisc") or "")) ()
		assert (loadstring (GetVariable ("TableIndex") or "")) ()
		
		if EpicMisc["NotificationBot"]["Commands"]["spouse"] == nil then
			EpicMisc["NotificationBot"]["Commands"]["spouse"] = false
			EpicMisc["NotificationBot"]["Auto"]["spouse"] = false
		end
		
		if EpicMisc["TypeTime"] == nil then
			EpicMisc["TypeTime"] = "SERVER"
		end
	else
		TableIndex = 0
		EpicTable = {}
		EpicMisc = {}
		EpicMisc["VI"] = "NO"
		EpicMisc["TypeTime"] = "SERVER"
		EpicMisc["Updating"] = "NO"
		EpicMisc["BlacklistEnabled"] = false
		EpicMisc["Blacklist"] = {}
		EpicMisc["ApproxRunTimes"] = {}
		EpicMisc["ApproxRunTimes"]["Grouping Time"] = {}
		EpicMisc["ApproxRunTimes"]["Grouping Time"]["Time"] = 5
		EpicMisc["ApproxRunTimes"]["Grouping Time"]["Enabled"] = false
		EpicMisc["ApproxRunTimes"]["transcendence"] = 120
		EpicMisc["ApproxRunTimes"]["genie"] = 25
		EpicMisc["ApproxRunTimes"]["icefall1"] = 45
		EpicMisc["ApproxRunTimes"]["icefall2"] = 60
		EpicMisc["ApproxRunTimes"]["inferno"] = 60
		EpicMisc["ApproxRunTimes"]["oc"] = 10
		EpicMisc["ApproxRunTimes"]["winds"] = 15
		EpicMisc["NoteRooms"] = {}
		EpicMisc["NoteRooms"][32418] = {}
		EpicMisc["NoteRooms"][32418]["Area"] = "aylor"
		EpicMisc["NoteRooms"][32418]["Name"] = "The Grand City of Aylor"
		EpicMisc["NotificationBot"] = {}
		EpicMisc["NotificationBot"]["Enabled"] = false
		EpicMisc["NotificationBot"]["Commands"] = {}
		EpicMisc["NotificationBot"]["CommandsEnabled"] = false
		EpicMisc["NotificationBot"]["Commands"]["spouse"] = false
		EpicMisc["NotificationBot"]["Commands"]["gt"] = false
		EpicMisc["NotificationBot"]["Commands"]["tell"] = false
		EpicMisc["NotificationBot"]["Commands"]["clan"] = false
		EpicMisc["NotificationBot"]["Commands"]["ft"] = false
		EpicMisc["NotificationBot"]["Permissions"] = "list"
		EpicMisc["NotificationBot"]["AutoEnabled"] = false
		EpicMisc["NotificationBot"]["Auto"] = {}
		EpicMisc["NotificationBot"]["Auto"]["spouse"] = false
		EpicMisc["NotificationBot"]["Auto"]["gt"] = false
		EpicMisc["NotificationBot"]["Auto"]["clan"] = false
		EpicMisc["NotificationBot"]["Auto"]["ft"] = false
		EpicMisc["NotificationBot"]["Alert"] = {}
		EpicMisc["NotificationBot"]["AlertEnabled"] = false
		EpicMisc["PostedNotes"] = {}
		EpicPermissionTable = {}
	end

	EpicLeaders = {
		[1] = "kers",
		[2] = "shaelynne",
		[3] = "hazeknight",
		[4] = "roume",
		[5] = "areia"
	}
		
	SystemTimeTable = {
      month = 0,
      wday = 0,
      yday = 0,
      day = 0,
      min = 0,
      isdst = false,
      sec = 0,
      hour = 0,
      year = 0,
    }

	Helpers = {
		["Quadrapus"] = "Helped with coming up with the original idea for the plugin",
		["Hadar"] = "Various code advice",
		["Fiendish"] = "Various code advice including table sorting",
		["Areia"] = "Primary beta tester",
		["Durel"] = "Provided changelog code",
		["Pwar"] = "Borrowed update code from their script",
	}
		
	EpicMobs = {
		[1] = "alai",
		[2] = "orbury",
		[3] = "kasiln",
	}
	
	DaysofWeek = {
		[1] = "sunday",
		[2] = "monday",
		[3] = "tuesday",
		[4] = "wednesday",
		[5] = "thursday",
		[6] = "friday",
		[7] = "saturday",
	}

	DaysofWeekShort = {
		[1] = "sun",
		[2] = "mon",
		[3] = "tue",
		[4] = "wed",
		[5] = "thu",
		[6] = "fri",
		[7] = "sat",
	}

	MonthMaxDays = {
		[1] = 31,
		[2] = 28,
		[3] = 31,
		[4] = 30,
		[5] = 31,
		[6] = 30,
		[7] = 31,
		[8] = 31,
		[9] = 30,
		[10] = 31,
		[11] = 30,
		[12] = 31,
	}
	
	Months = {
		[1] = "jan",
		[2] = "feb",
		[3] = "mar",
		[4] = "apr",
		[5] = "may",
		[6] = "jun",
		[7] = "jul",
		[8] = "aug",
		[9] = "sep",
		[10] = "oct",
		[11] = "nov",
		[12] = "dec",
	}

	MonthsYDay = {
		[1] = 0,
		[2] = 31,
		[3] = 59,
		[4] = 90,
		[5] = 120,
		[6] = 151,
		[7] = 181,
		[8] = 212,
		[9] = 242,
		[10] = 273,
		[11] = 304,
		[12] = 334,
	}


	EpicNames = {
		[1] = "genie",
		[2] = "icefall1",
		[3] = "icefall2",
		[4] = "inferno",
		[5] = "oc",
		[6] = "winds",
		[7] = "terra",
		[8] = "titan",
		[9] = "icefall",
		[10] = "if1",
		[11] = "if2",
		[12] = "oldvanir",
		[13] = "testmaze10",
		[14] = "transcendence", 
		[15] = "transcend", 
		[16] = "ts", 
		[17] = "fractals",
	}

	SearchNames = {
		["genie"] = "Genie's Last Wish",
		["inferno"] = "Journey to the Inferno",
		["oc"] = "Oradrins Chosen",
		["winds"] = "Winds of Fate",
		["terra"] = "Cracks of Terra",
		["titan"] = "Titans Keep",
		["oldvanir"] = "oldvanir",
		["testmaze10"] = "testmaze10",
		["transcendence"] = "transcendence", 
		["fractals"] = "fractals",
	}

	ApprovedChannels = {
		[1] = "gtell",
		[2] = "ftalk",
		[3] = "clantalk",
		[4] = "tell",
		[5] = "ctalk",
		[6] = "spouse",
	}
	
	UnApprovedChannels = {
		[1] = "answer",
		[2] = "barter",
		[3] = "cant",
		[4] = "curse",
		[5] = "debate",
		[6] = "epics",
		[7] = "gametalk",
		[8] = "gclan",
		[9] = "gossip",
		[10] = "gratz",
		[11] = "immtalk",
		[12] = "lasertag",
		[13] = "mafiainfo",
		[14] = "market",
		[15] = "music",
		[16] = "pokerinfo",
		[17] = "question",
		[18] = "racetalk",
		[19] = "rp",
		[20] = "sports",
		[21] = "tech",
		[22] = "tiertalk",
		[23] = "wangrp",
		[24] = "tt",
	}

	-- Borrowed for SnD
	AreaNames = {
		-- A --
		["aardington"] = "Aardington Estate",
		["academy"] = "Academy",
		["adaldar"] = "Battlefields of Adaldar",
		["afterglow"] = "Afterglow",
		["agroth"] = "Marshlands of Agroth",
		["ahner"] = "Kingdom of Ahner",
		["alehouse"] = "Wayward Alehouse",
		["amazon"] = "Amazon Nation",
		["amusement"] = "Amusement Park",
		["andarin"] = "Blighted Tundra of Andarin",
		["annwn"] = "Annwn",
		["anthrox"] = "Anthrox",
		["arena"] = "Gladiator's Arena",
		["arisian"] = "Arisian Realm",
		["ascent"] = "First Ascent",
		["astral"] = "Astral Travels",
		["atlantis"] = "Atlantis",
		["autumn"] = "Eternal Autumn",
		["avian"] = "Avian Kingdom",
		["aylor"] = "Grand City Aylor",
		-- B --
		["badtrip"] = "Bad Trip",
		["bazaar"] = "Onyx Bazaar",
		["beer"] = "Land of Beer Goblins",
		["believer"] = "Path of the Believer",
		["blackrose"] = "Black Rose",
		["bliss"] = "Wedded Bliss",
		-- C --
		["caldera"] = "Icy Caldera Mauldoon",
		["callhero"] = "Call of Heroes",
		["camps"] = "Tournament Camps",
		["canyon"] = "Canyon Memorial Hospital",
		["caravan"] = "Gypsy Caravan",
		["cards"] = "House of Cards",
		["carnivale"] = "Olde Worlde Carnivale",
		["cataclysm"] = "Cataclysm",
		["cathedral"] = "Old Cathedral",
		["cats"] = "Sheila's Cat Sanctuary",
		["chasm"] = "Chasm and Catacombs",
		["chessboard"] = "Chessboard",
		["childsplay"] = "Child's Play",
		["cineko"] = "Aerial City of Cineko",
		["citadel"] = "Flying Citadel",
		["conflict"] = "Thandeld's Conflict",
		["coral"] = "Coral Kingdom",
		["cougarian"] = "Cougarian Queendom",
		["cove"] = "Kiksaadi Cove",
		["cradle"] = "Cradlebrook",
		["crynn"] = "Crynn's Church",
		-- D --
		["damned"] = "Halls of the Damned",
		["darklight"] = "Darklight",
		["darkside"] = "Darkside Fractured Lands",
		["ddoom"] = "Desert Doom",
		["deadlights"] = "Deadlights",
		["deathtrap"] = "Deathtrap Dungeon",
		["deneria"] = "Realm of Deneria",
		["desert"] = "Desert Prison",
		["desolation"] = "Mountains of Desolation",
		["dhalgora"] = "Dhal'Gora Outlands",
		["diatz"] = "Three Pillars Diatz",	
		["diner"] = "Tumari's Diner",
		["dortmund"] = "Dortmund",
		["drageran"] = "Drageran Empire",
		["dread"] = "Dread Tower",
		["dsr"] = "Diamond Soul Revelation",
		["dundoom"] = "Dungeon Doom",
		["dunoir"] = "Mount DuNoir",
		["duskvalley"] = "Dusk Valley",
		["dynasty"] = "Eighteenth 18th Dynasty",
		-- E --
		["earthlords"] = "Earth Lords",
		["earthplane"] = "Earth Plane 4",
		["elemental"] = "Elemental Chaos",
		["empire"] = "Empire of Aiighialla",
		["empyrean"] = "Empyrean Streets of Downfall",
		["entropy"] = "Archipelago Entropy",
		-- F --
		["fantasy"] = "Fantasy Fields",
		["farm"] = "Kimr's Farm",
		["fayke"] = "All in Fayke Day",
		["fens"] = "Curse Midnight Fens",
		["fields"] = "Killing Fields",
		["firebird"] = "Realm of the Firebird",
		["firenation"] = "Realm of the Sacred Flame",
		["fireswamp"] = "Fire Swamp",
		["fortress"] = "Goblin Fortress",
		["fractured"] = "Fractured Lands",
		["ft1"] = "Faerie Tales",
		["ftii"] = "Faerie Tales II FT2",
		-- G --
		["gallows"] = "Gallows Hill",
		["gathering"] = "Gathering Horde",
		["gauntlet"] = "Gauntlet",
		["genie"] = "Genie's Last Wish",
		["gilda"] = "Gilda and the Dragon",
		["glamdursil"] = "Glamdursil",
		["glimmerdim"] = "Brightsea Glimmerdim",
		["gnomalin"] = "Cloud City of Gnomalin",
		["goldrush"] = "Gold Rush",
		["graveyard"] = "Graveyard",
		["greece"] = "Ancient Greece",
		["gwillim"] = "Trouble with Gwillimberry",
		-- H --
		["hatchling"] = "Hatchling Aerie",
		["hawklord"] = "Realm of the Hawklords",
		["hedge"] = "Hedgehog's",
		["helegear"] = "Helegear Sea",
		["hell"] = "Descent to Hell",
		["hoard"] = "Swordbreaker's Hoard",
		["hodgepodge"] = "Magical Hodgepodge",
		["horath"] = "Broken Halls of Horath",
		["horizon"] = "Nebulous Horizon",
		-- I --
		["icefall"] = "Icefall",
		["illoria"] = "Illoria",
		["imagi"] = "Imagi's Nation",
		["imperial"] = "Imperial Nation",
		["infamy"] = "Realm of Infamy",
		["inferno"] = "Journey to the Inferno",
		["infest"] = "Infestation",
		["insan"] = "Insanitaria",
		-- J --
		["jenny"] = "Jenny's Tavern",
		["jotun"] = "Jotunheim",
		-- K --
		["kearvek"] = "Keep of Kearvek",
		["kerofk"] = "Kerofk",
		["ketu"] = "Ketu Uplands",
		["kingsholm"] = "Kingsholm",
		["knossos"] = "Great City of Knossos",
		["kobaloi"] = "Keep of the Kobaloi",
		["kultiras"] = "Kul Tiras",
		-- L --
		["lab"] = "Chaprenula's Laboratory",
		["labyrinth"] = "Labyrinth",
		["lagoon"] = "Black Lagoon",
		["landofoz"] = "Land of Oz",
		["laym"] = "Tai'rha Laym",
		["legend"] = "Land of Legend LoL",
		["lemdagor"] = "Storm Ships of Lem-Dagor",
		["lidnesh"] = "Forest of Li'Dnesh",
		["livingmine"] = "Living Mines of Dak'Tai",
		["longnight"] = "Into the Long Night",
		["losttime"] = "Island of Lost Time",
		["lplanes"] = "Lower Planes",
		-- M --
		["maelstrom"] = "Maelstrom",
		["manor"] = "Death's Manor",
		["masq"] = "Masquerade Island",
		["mayhem"] = "Artificer's Mayhem",
		["melody"] = "Art of Melody",
		["minos"] = "Shadows of Minos",
		["mistridge"] = "Covenant of Mistridge",
		["monastery"] = "Monastery",
		["mudwog"] = "Mudwog's Swamp",
		-- N --
		["nanjiki"] = "Nanjiki Ruins",
		["necro"] = "Necromancer's Guild",
		["nenukon"] = "Nenukon and the Far Country",
		["newthalos"] = "New Thalos",
		["northstar"] = "Northstar",
		["nottingham"] = "Nottingham",
		["nulan"] = "Plains of Nulan'Boar",
		["nursing"] = "Ascension Bluff Nursing Home",
		["nynewoods"] = "Nyne Woods",
		-- O --
		["oc"] = "Oradrin's Chosen",
		["oceanpark"] = "Ocean Adventure Park",
		["omentor"] = "Witches of Omen Tor",
		["origins"] = "Tribal Origins",
		["orlando"] = "Hotel Orlando",
		-- P --
		["paradise"] = "Paradise Lost",
		["peninsula"] = "Tairayden Peninsula",
		["petstore"] = "Giant's Pet Store",
		["pompeii"] = "Pompeii",
		["promises"] = "Foolish Promises",
		["prosper"] = "Prosper's Island",
		-- Q --
		["qong"] = "Qong",
		["quarry"] = "Gnoll's Quarry",
		-- R --		
		["radiance"] = "Radiance Woods",
		["raga"] = "Raganatittu",
		["raukora"] = "Blood Opal of Rauko'ra",
		["rebellion"] = "Rebellion Nix",
		["remcon"] = "Reman Conspiracy",
		["reme"] = "City of Reme",
		["rosewood"] = "Rosewood Castle",
		["ruins"] = "Ruins of Diamond Reach",
		-- S --
		["sagewood"] = "Sagewood Grove",
		["sahuagin"] = "Abyssal Caverns of Sahuagin",
		["salt"] = "Great Salt Flats",
		["sanctity"] = "Sanctity of Eternal Damnation",
		["sanctum"] = "The Blood Sanctum",
		["sandcastle"] = "Sho'aram Shoaram Castle in the Sand",
		["sanguine"] = "Sanguine Tavern",
		["scarred"] = "Scarred Lands",
		["sendhian"] = "Adventures in Sendhia",
		["sennarre"] = "Sen'narre Lake",
		["shouggoth"] = "Temple of Shouggoth",
		["siege"] = "Kobold Seige Camp KSC",
		["sirens"] = "Siren's Oasis Resort",
		["slaughter"] = "Slaughterhouse",
		["snuckles"] = "Snuckles Village",
		["soh"] = "School of Horror SOH1",
		["sohtwo"] = "School of Horror SOH2",
		["solan"] = "Town of Solan",
		["songpalace"] = "Palace of Song",
		["spyreknow"] = "Guardian's Spyre of Knowledge",
		["stone"] = "Fabled City of Stone",
		["storm"] = "Storm Mountain",
		["stormhaven"] = "Ruins of Stormhaven",
		["stronghold"] = "Dark Elf Stronghold DES",
		["stuff"] = "Stuff of Shadows",
		-- T --
		["takeda"] = "Takeda's Warcamp",
		["talsa"] = "Empire of Talsa",
		["temple"] = "Temple of Shal'indrael",
		["tanra"] = "Tanra'vea",
		["terra"] = "Cracks of Terra",
		["terramire"] = "Fort Terramire",
		["thieves"] = "Den of Thieves",
		["times"] = "Intrigues of Times Past",
		["tirna"] = "Tir na Nog",
		["titan"] = "Titans' Keep",
		["tol"] = "Tree of Life",
		["tombs"] = "Relinquished Tombs",
		-- U --
		["umari"] = "Umari's Castle",
		["underdark"] = "Underdark",
		["uplanes"] = "Upper Planes",
		["uprising"] = "Uprising",
		-- V --
		["vale"] = "Sundered Vale",
		["verdure"] = "Verdure Estate",
		["verume"] = "Jungles of Verume",
		["village"] = "Peaceful Giant Village",
		["vlad"] = "Vlad Shamir",
		["volcano"] = "Silver Volcano",
		-- W --
		["weather"] = "Weather Observatory",
		["werewood"] = "Were Wood",
		["wildwood"] = "Wildwood",
		["winds"] = "Winds of Fate",
		["winter"] = "Winterlands",
		["wizards"] = "War of the Wizards WoW",
		["wonders"] = "Seven Wonders",
		["wooble"] = "Wobbly Woes of Woobleville",
		["woodelves"] = "Wood Elves of Nalondir",
		["wtc"] = "Warrior Training Camp WTC",
		["wyrm"] = "Council of the Wyrm",
		-- X --
		["xmas"] = "Christmas Vacation",
		["xylmos"] = "Xyl's Mosaic",
		-- Y --
		["yarr"] = "Misty Shores of Yarr",
		["ygg"] = "Yggdrasil: The World Tree",
		["yurgach"] = "Yurgach Domain",
		-- Z --
		["zangar"] = "Zangar's Demonic Grotto",
		["zodiac"] = "Realm of the Zodiac",
		["zoo"] = "Aardwolf Zoological Park",
		["zyian"] = "Dark Temple of Zyian",
	}
	
	sametimezone = "NO"
	
	SaveState()
end -- GetSavedData

function Connected()
	ran = true
	
	TableFilled = "NO"
	
	ResetEpicTable()	

	if EpicMisc["NotificationBot"]["Enabled"] == true then EnableBot() end	
end -- Connected

function OnPluginInstall()
	PLUGIN_VERSION  = GetPluginInfo(GetPluginID(), 19)
	PLUGIN_NAME   = GetPluginInfo(GetPluginID(), 1)

	GetSavedData()	

	if EpicMisc["Updating"] == "YES" then
		EpicMisc["Updating"] = "NO"
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Update complete.")
	elseif EpicMisc["Updating"] == "NO" then
		ColourNote(epiccalcolour, "", "[EpicCAL] ", msg_colour, "", "Thank you for installing ", qty_colour, "", "Tallimos' Epic Calendar v" ..  PLUGIN_VERSION, msg_colour, "", ". Please see ", help_command_colour, "", "ecal help", msg_colour, "", " for more information.")
	end
	
	Note("")

	if IsConnected() then
		if not ran then Connected() end
	end
end -- OnPluginInstall

function OnPluginEnable()
	GetSavedData()	

	if IsConnected() then
		if not ran then Connected() end
	end
end -- OnPluginEnable

function OnPluginSaveState()
	SetVariable ("EpicTable", "EpicTable = " .. serialize.save_simple (EpicTable))
	SetVariable ("EpicPermissionTable", "EpicPermissionTable = " .. serialize.save_simple (EpicPermissionTable))
	SetVariable ("EpicMisc", "EpicMisc = " .. serialize.save_simple (EpicMisc))
	SetVariable ("TableIndex", "TableIndex = " .. serialize.save_simple (TableIndex))
	SetVariable ("ecpastfirstinstall", "true")
end -- OnPluginSaveState

function OnPluginBroadcast(msg, id, name, text)
	if id == "3e7dedbe37e44942dd46d264" then
		if text == "char.status" then
			local s = gmcp("char.status.state")
			if not ran then
				if s == "3" or s == "11" then
					Connected()
				end
			end
		elseif (text == 'comm.tick') then		
			gmcptick = gmcp("comm.tick")
			
			sertime = gmcptick.time
			SetServerTime(sertime)
			sertime2 = gmcptick.ctime
			
			OSSystemTimeTable = os.date("*t")
			OSSystemTime = os.time()

			if behindcheck == nil then 
				behindcheck = "NO"

				timenow2 = os.time(SystemTimeTable)
				timenow = OSSystemTime

				timediff2 = {}

				if timenow < timenow2 then 
					timeDiff(timenow2,timenow,timediff2)
					behindcheck = "YES"
				elseif timenow > timenow2 then
					timeDiff(timenow,timenow2,timediff2)
				elseif timenow == timenow2 then
					sametimezone = "YES"
				end

				timezonedifference = {}
				
				for i,v in pairs(timediff2) do
					timezonedifference[i] = v
				end
			end
			
			if TableFilled == "YES" then 
			
				if EpicMisc["NotificationBot"]["Enabled"] == true then
					if EpicMisc["NotificationBot"]["AlertEnabled"] == true then
						if alertremaining == nil then
							AlertCheck()
						else
							timenow = os.time(SystemTimeTable)
							-- timenow = sertime2
							timenow2 = alerttime
							
							timediff2 = {}

							timeDiff(timenow,timenow2,timediff2)
							
							if timediff2["day"] == 0 then
								if timediff2["hour"] == 0 then
									if timediff2["min"] > 4 then
										-- alertcheck = nil
										GetNextEpicSilent()
									end
								end
							end
						end
					end
				end
			end
		end
	end	
end -- OnPluginBroadcast

-- Update code taken from Pwar's installer menu
function ecal_install(name, line, wc)
   for p = 1, #pluginList do
      if pluginList[p] ~= nil and tonumber(wc.index) == p then
         printmsg("Attempting to install plugin #" .. wc.index .. " (" .. pluginList[p].name .. ")")
         install_plugin(pluginList[p])
      end
   end
   if #pluginList == 0 then
      printmsg("Error: Unable to read plugin index.")
   end
end

function ecal_update(name, line, wc)
	printmsg("*** Checking if update is available for Tallimos' Epic Calendar.. Please wait.\r\n\r\n")
	local url = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/EpicCalendar/Tallimos_EpicCalendar.xml"
	async.doAsyncRemoteRequest(url, async_ecal_download_complete, "HTTPS", 120)
end

function async_ecal_download_complete(retval, page, status, headers, full_status, request_url)
  if status == 200 then
    local version = tonumber(string.match(page, '%s%s+version="([0-9%.]+)"'))
    local installedVer = GetPluginInfo(GetPluginID(), 19)
    if version > installedVer then
      printmsg("Updating from version " .. installedVer .. " to version " .. version)
      local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
      page = string.gsub(page, "\r", "")
      file:write(page)
      file:close()
      if GetAlphaOption("script_prefix") == "" then SetAlphaOption("script_prefix", "\\\\\\") end
      Execute(GetAlphaOption("script_prefix").."DoAfterSpecial(1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
    else
      printmsg("You already have the latest version of Tallimos' Epic Calendar installed.")
    end
  else
      printmsg("Plugin update check failed...Error " .. tostring(status))
  end
end

function async_plugin_download_complete(retval, page, status, headers, full_status, request_url)
   local folder
   local xmlFiles = {}
   local xmlFile = {}
   if updatePlugin.installpath == "1" then
      folder = GetInfo(66)
   else
      folder = GetPluginInfo(GetPluginID(), 20)
   end
   --print("FOLDER IS " .. folder)
   if status == 200 then -- download successful
      printmsg("----------------------------------------------")
      printmsg("*** " .. updatePlugin.name .. " download successful.")
      f = assert(io.open (folder .. "temp_update.zip", "wb"))
      f:write(page)
      f:close()
      local zfile, err = zip.open(folder .. "temp_update.zip")
      printmsg("Extracting files from zip:")
      for file in zfile:files() do
         local currFile, err = zfile:open(file.filename)
         local currFileContents = currFile:read("*a") -- read entire contents of current file
         local hBinaryOutput = io.open(folder .. file.filename, "wb")
          -- write current file inside zip to a file outside zip
          if(hBinaryOutput)then
              hBinaryOutput:write(currFileContents)
              hBinaryOutput:close()
          end
         printmsg("(+) " .. file.filename)
         local fileExt = string.sub(file.filename, -4)
         if fileExt == ".xml" then
            xmlFile.filename = file.filename
            --print(xmlFile.filename)
            xmlFile.pluginid = string.match(currFileContents, '%s%s+id="(.-)"')            
            table.insert(xmlFiles, xmlFile)
            xmlFile = {}
         end
         currFile:close()
      end
      os.remove(folder .. "temp_update.zip")
      printmsg("Update succeeded, loading/reloading plugins.")
      printmsg("----------------------------------------------")
      for i = 1, #updatePlugin.ids do
         --if not IsPluginInstalled(thisPlugin.ids[i]) then
            --LoadPlugin(folder ..  
         --end
         --(IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
         --ReloadPlugin(updatePlugin.ids[i])
      end
      for i = 1, #xmlFiles do
         --print(xmlFiles[i].filename, xmlFiles[i].pluginid)
         --local version = tonumber(string.match(page, '%s%s+version="([0-9%.]+)"'))
         if not (IsPluginInstalled(xmlFiles[i].pluginid) and GetPluginInfo(xmlFiles[i].pluginid, 17)) then
            LoadPlugin(folder .. xmlFiles[i].filename)
         else
            ReloadPlugin(xmlFiles[i].pluginid)
         end
         installedPlugins[xmlFiles[i].pluginid] = headers["etag"]
      end
      SaveState()
   else
      printmsg("Plugin download failed...Error " .. tostring(status))
      --printmsg(headers["location"])
   end
   updatePlugin = {}
   xmlFiles = {}
end

function async_xml_download_complete(retval, page, status, headers, full_status, request_url)
   if status == 200 then
      --print(page)
      --print(status)
      lastListHash = headers["etag"]
      SaveState()
      local xml = utils.xmlread(page)
      local num_plugins = #xml.nodes [2].nodes
      --print(num_plugins)
      pluginList = {}
      for p = 1,num_plugins do
         num_plugin_nodes = #xml.nodes [2].nodes [p].nodes
         local thisPlugin = {}
         thisPlugin.ids = {}
         for n = 1, num_plugin_nodes do
            local xmlkey = xml.nodes [2].nodes [p].nodes [n].name
            local xmlval = xml.nodes [2].nodes [p].nodes [n].content
            if xmlkey == "name" then thisPlugin.name = xmlval
            elseif xmlkey == "author" then thisPlugin.author = xmlval
            elseif xmlkey == "description" then thisPlugin.description = xmlval
            elseif xmlkey == "id" then table.insert(thisPlugin.ids, xmlval)
            elseif xmlkey == "download" then thisPlugin.download = xmlval
            elseif xmlkey == "installpath" then thisPlugin.installpath = xmlval
            end
         end
         require "tprint"
         pluginList[p] = thisPlugin
         thisPlugin.installed = true
         for i = 1, #thisPlugin.ids do
            if not (IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
               thisPlugin.installed = false
               --print("Plugin not installed and enabled!!" .. thisPlugin.ids[i])
            end
         end
      end
      lastPluginList = pluginList
      SaveState()
      for p = 1, #pluginList do
         get_plugin_info(pluginList[p])
      end
   else
      printmsg("Downloading plugin list failed...Error " .. tostring(status))
   end
end

function get_plugin_info(plugin)
   local http_mode = string.sub(plugin.download, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   async.HEAD(plugin.download, async_head_plugin, http_mode, 120)
end

function install_plugin(plugin)
   --print("plugin.ids[1]: " .. plugin.ids[1])
   url = plugin.download
   local http_mode = string.sub(url, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   updatePlugin = plugin
   async.doAsyncRemoteRequest(url, async_plugin_download_complete, http_mode, 120)
end

function printmsg(msg)
   ColourNote("cornflowerblue", "", msg)
end

-- Changelog code courtesy of Durel
pluginId        = "1d1e01d90f0e2983c358b32e"

dbot = {}
----------------------------------------------------------------------------------------------------
-- dbot.version: Track the plugin's version and changelog and update the plugin 
--
-- dbot.version.changelog.get(minVersion, endTag)
-- dbot.version.changelog.getCR()
-- dbot.version.changelog.displayChanges(minVersion, changeLog)
-- dbot.version.changelog.displayChange(changeLogEntries)
--
-- dbot.version.update.release(mode, endTag)
-- dbot.version.update.releaseCR()
-- Note: dbot.version.update is derived from a plugin written by Arcidayne.  Thanks Arcidayne!
----------------------------------------------------------------------------------------------------

dbot.version               = {}

dbot.version.changelog     = {}
dbot.version.changelog.pkg = nil

dbot.version.update        = {}
dbot.version.update.pkg    = nil

drlDbotUpdateCheck         = "check"
drlDbotUpdateInstall       = "install"

drlDbotChangeLogTypeFix    = "@RFix@W"
drlDbotChangeLogTypeNew    = "@GNew@W"
drlDbotChangeLogTypeMisc   = "@yMsc@W"

function dbot.version.changelog.get(minVersion, endTag)
  local url      = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/EpicCalendar/epiccalendar.changelog"
  local protocol = "HTTPS"

  if (dbot.version.changelog.pkg ~= nil) then
    Note("Skipping changelog request: another request is in progress")
  end -- if

  dbot.version.changelog.pkg            = {}
  dbot.version.changelog.pkg.url        = url
  dbot.version.changelog.pkg.protocol   = protocol
  dbot.version.changelog.pkg.minVersion = minVersion or 0
  dbot.version.changelog.pkg.endTag     = endTag
 
  dbot.version.changelog.getCR()
end -- dbot.version.changelog.get

function dbot.version.changelog.getCR()

  if (dbot.version.changelog.pkg == nil) then
    dbot.print("dbot.version.changelog.getCR: Change log package is missing!")
  end -- if

  local fileData = dbot.remote.get(dbot.version.changelog.pkg.url,
                                           dbot.version.changelog.pkg.protocol)
	if (fileData == nil) then
    dbot.print("@DNo changelog information was found. Please report to @CTallimos@D.")

  else
    loadstring(fileData)()
    if (dbot.changelog == nil) then
      dbot.print("dbot.version.changelog.getCR: Invalid changelog format detected")
    else
      dbot.version.changelog.displayChanges(dbot.version.changelog.pkg.minVersion, dbot.changelog)
    end -- if
  end -- if

  dbot.version.changelog.pkg = nil
end -- dbot.version.changelog.getCR

function dbot.version.changelog.displayChanges(minVersion, changeLog)
  local sortedLog = {}

  for k, v in pairs(changeLog) do
    table.insert(sortedLog, { version = tonumber(k) or 0, changes = v})
  end -- for
  table.sort(sortedLog, function (v1, v2) return v1.version < v2.version end)

  for _, clog in ipairs(sortedLog) do
    if (clog.version > minVersion) then
      dbot.version.changelog.displayChange(clog)
    end -- if
  end -- for

end -- dbot.version.changelog.displayChanges

-- Format of entry is: { version = 2.13,
--                       changes = { { change = drlDbotChangeLogTypeXYZ, desc = "what changed" }
--                                 }
--                     }
function dbot.version.changelog.displayChange(changeLogEntries)

  if (changeLogEntries == nil) then
    dbot.print("dbot.version.changelog.displayChange: Change entries are missing!")
    return
  end -- if

  dbot.print(string.format("@Cv%1.2f@W", changeLogEntries.version))
  for _, logEntry in ipairs(changeLogEntries.changes) do
    dbot.print(string.format("@W    (%s): %s", logEntry.change, logEntry.desc))
  end -- for
end -- dbot.version.changelog.displayChange

function dbot.version.update.release(mode, endTag)
  local url      = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/EpicCalendar/Tallimos_EpicCalendar.xml"
  local protocol = "HTTPS"
  local retval   = DRL_RET_SUCCESS

  if (mode == nil) or ((mode ~= drlDbotUpdateCheck) and (mode ~= drlDbotUpdateInstall)) then
    dbot.print("dbot.version.update.release: Missing or invalid mode parameter")
  end -- if

  if (dbot.version.update.pkg ~= nil) then
    Note("Skipping update request: another update request is in progress")
  end -- if

  dbot.version.update.pkg          = {}
  dbot.version.update.pkg.mode     = mode
  dbot.version.update.pkg.url      = url
  dbot.version.update.pkg.protocol = protocol
  dbot.version.update.pkg.endTag   = endTag

	dbot.version.update.releaseCR()	
  return retval
end -- dbot.version.update.release

function dbot.version.update.releaseCR()

  if (dbot.version.update.pkg == nil) or (dbot.version.update.pkg.mode == nil) then
    dbot.error("dbot.version.update.releaseCR: Missing or invalid update package detected")
  end -- if

  local endTag = dbot.version.update.pkg.endTag

  -- This blocks until the plugin file is returned, an error is detected, or we time out
  local pluginData, retval = dbot.remote.get(dbot.version.update.pkg.url, dbot.version.update.pkg.protocol)
  if (retval ~= DRL_RET_SUCCESS) then
    dbot.print("dbot.version.update.releaseCR: Failed to retrieve latest plugin file: " ..
              dbot.retval.getString(retval))

  elseif (pluginData == nil) then
    dbot.print("@DCould not find a remote plugin release")
    retval = DRL_RET_MISSING_ENTRY

  else
    local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
    local currentVerStr  = string.format("%1.2f", currentVersion)
    local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
    local remoteVersion  = tonumber(remoteVerStr or "") or 0

    if (remoteVersion == currentVersion) then
      dbot.print("@DYou are running the latest version of the plugin (v@C" .. currentVerStr .. "@D)")

    elseif (remoteVersion < currentVersion) then
      dbot.print("@DYour current plugin (v@C" .. currentVerStr .. "@D) " ..
                "is newer than the latest official release (v@C" .. remoteVerStr .. "@D)")
      retval = DRL_RET_VER_MISMATCH

    elseif (dbot.version.update.pkg.mode == drlDbotUpdateCheck) then
      dbot.print("@DYou are running v@C" .. currentVerStr .. "@D, latest version is v@C" .. remoteVerStr)
      dbot.print("@DChanges since your last update:")
      dbot.version.update.pkg = nil
      return dbot.version.changelog.get(currentVersion, endTag)

    elseif (dbot.version.update.pkg.mode == drlDbotUpdateInstall) then
      dbot.print("@DUpdating plugin from version @C" .. currentVerStr .. " @Dto version @C" .. remoteVerStr) 
      dbot.print("@DPlease wait until the update is complete.")

      local pluginFile = GetPluginInfo(GetPluginID(), 6)
      local file = io.open(pluginFile, "w")
      file:write(pluginData)
      file:close()
	  
	  dbot.reload()
    else
      dbot.print("@Ddbot.version.update.callback: Detected invalid mode \"@R" ..
                 (dbot.version.update.pkg.mode or "nil") .. "@W\"")
    end -- if

  end -- if

  dbot.version.update.pkg = nil

end -- dbot.version.update.releaseCR

----------------------------------------------------------------------------------------------------
-- Module to retrieve remote files
--
-- dbot.remote.get(url, protocol)
-- dbot.remote.getCR()
--
----------------------------------------------------------------------------------------------------

dbot.remote        = {}
dbot.remote.getPkg = nil

-- Blocks and then returns file, retval
-- Must be called from within a co-routine
function dbot.remote.get(url, protocol)
  local retval   = DRL_RET_SUCCESS
  local fileData = nil

  if (url == nil) or (url == "") then
    dbot.print("dbot.remote.get: missing url parameter")
    return fileData, DRL_RET_INVALID_PARAMETER
  end -- if

  if (protocol == nil) or (protocol == "") then
    dbot.print("dbot.remote.get: missing protocol parameter")
    return fileData, DRL_RET_INVALID_PARAMETER
  end -- if

  if (dbot.remote.getPkg ~= nil) then
    dbot.info("Skipping remote request: another request is in progress")
    return fileData, DRL_RET_BUSY
  end -- if

  dbot.remote.getPkg          = {}
  dbot.remote.getPkg.url      = url
  dbot.remote.getPkg.protocol = protocol
  dbot.remote.getPkg.isDone   = false

	dbot.remote.getCR()
  local timeout = 10
  local totTime = 0
  while (dbot.remote.getPkg.isDone == false) do
    if (totTime > timeout) then
      break
    end -- if
  end -- while

  if (dbot.remote.getPkg ~= nil) and (dbot.remote.getPkg.fileData ~= nil) then
    fileData = dbot.remote.getPkg.fileData
  else
    dbot.print("@DFailed to find data for file\n \"@C" .. url .. "@W\"")
  end -- if

  dbot.remote.getPkg = nil
  return fileData

end -- dbot.remote.get

function dbot.remote.getCR()
  if (dbot.remote.getPkg == nil) or (dbot.remote.getPkg.url == nil) then
    dbot.error("dbot.remote.getCR: remote package is nil or corrupted!")
    dbot.remote.getPkg = nil
    return 
  end -- if

  local urlThread = async.request(dbot.remote.getPkg.url, dbot.remote.getPkg.protocol)

  if (urlThread == nil) then
    dbot.print("dbot.remote.getCR: Failed to create thread requesting remote data")

  else
    local timeout = 10
    local totTime = 0
    while (urlThread:alive()) do
      if (totTime > timeout) then
        break
      end -- if
    end -- while

    local remoteRet, page, status, headers, fullStatus = urlThread:join()

    if (status ~= 200) then
      dbot.print("@DFailed to retrieve remote file")
    else
      dbot.remote.getPkg.fileData = page
    end -- if

    dbot.remote.getPkg.isDone = true

  end -- if
end -- dbot.remote.getCR

function dbot.print(string)
    AnsiNote(stylesToANSI(ColoursToStyles(string)))
end -- dbot.print

----------------------------------------------------------------------------------------------------
-- dbot.reload: Reloads the current plugin
--
-- Note: This code was derived from part of a plugin by Arcidayne.  Thanks Arcidayne!
----------------------------------------------------------------------------------------------------

function dbot.reload()
  local scriptPrefix = GetAlphaOption("script_prefix")
  local retval

  -- If the user has not already specified the script prefix for this version of mush, pick a
  -- reasonable default value
  if (scriptPrefix == "") then
    scriptPrefix = "\\\\\\"
    SetAlphaOption("script_prefix", scriptPrefix)
  end

  -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
  -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
  -- if it weren't installed? 
  retval = Execute(scriptPrefix.."DoAfterSpecial(1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
  if (retval ~= 0) then
    dbot.print("@Ddbot.reload: Failed to reload the plugin: mush error " .. retval)
  end -- if
end -- dbot.reload


]]>
</script> 
</muclient>
